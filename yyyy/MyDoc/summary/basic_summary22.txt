1、XML 与 JSON
    Xml介绍：XML的这些相关技术实现起来非常复杂，在实际应用中很少用到，通常了解一下就可以了。
    例子：
        ① DOM：一次性读取XML，并在内存中表示为树形结构；
            // 在classpath中的资源文件，路径总是以／开头，我们先获取当前的Class对象，
            //   然后调用getResourceAsStream()就可以直接从classpath读取任意的资源文件
            InputStream input = Main.class.getClassLoader().getResourceAsStream("book.xml");
            DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
            try {
                DocumentBuilder db = dbf.newDocumentBuilder();
                Document doc = db.parse(input);
                printNode(doc, 0);
                // 0 Document: #document
                //  1 Element: book
                //   2 Text: #text =
                //
                //   2 Element: name
                //    3 Text: #text = Java核心技术
                //   2 Text: #text =
            } catch (Exception e) {
                e.printStackTrace();
            }

            // 这是一个递归
            static void printNode(Node n, int indent) {
                for (int i = 0; i < indent; i++) {
                    System.out.print(" ");
                }
                switch (n.getNodeType()) {
                    case Node.DOCUMENT_NODE:    // Document节点
                        System.out.println(indent + " Document: " + n.getNodeName());
                        break;
                    case Node.ELEMENT_NODE:     // 元素节点
                        System.out.println(indent + " Element: " + n.getNodeName());
                        break;
                    case Node.TEXT_NODE:    // 文本
                        System.out.println(indent + " Text: " + n.getNodeName() + " = " + n.getNodeValue());
                        break;
                    case Node.ATTRIBUTE_NODE:   // 属性
                        System.out.println(indent + " Attribute: " + n.getNodeName() + " = " + n.getNodeValue());
                        break;
                    case Node.CDATA_SECTION_NODE:
                        System.out.println(indent + " CDATA: " + n.getNodeName() + " = " + n.getNodeValue());
                        break;
                    case Node.COMMENT_NODE:
                        System.out.println(indent + " Comment: " + n.getNodeName() + " = " + n.getNodeValue());
                        break;
                    default:
                        System.out.println(indent + " NodeType: " + n.getNodeType() + ", NodeValue: " + n.getNodeValue());
                }
                for (Node child = n.getFirstChild(); child != null; child = child.getNextSibling()) {
                    printNode(child, indent + 1);
                }
            }

        ② SAX：以流的形式读取XML，使用事件回调。
            InputStream input22 = Main.class.getClassLoader().getResourceAsStream("book.xml");
            SAXParserFactory spf = SAXParserFactory.newInstance();
            try {
                SAXParser saxParserObj = spf.newSAXParser();
                saxParserObj.parse(input22, new MyHandler());
                // start document
                // start element:  book
                // characters:
                //
                // start element:  name
                // characters: Java核心技术
                // end element:  name
                // characters:
                //
                // end element:  book
                // end document
            } catch (Exception e) {
                e.printStackTrace();
            }

        ③ 使用Jackson
            InputStream input33 = Main.class.getClassLoader().getResourceAsStream("book.xml");
            JacksonXmlModule module = new JacksonXmlModule();
            XmlMapper mapper = new XmlMapper(module);
            try {
                Book book = mapper.readValue(input33, Book.class);
                System.out.println(book.id);
                System.out.println(book.name);
            } catch (Exception e) {
                e.printStackTrace();
            }

    Json介绍：
        ① JSON只允许使用UTF-8编码，不存在编码问题
        ② 仅支持的数据类型：键值对：{"key": value}  ， 数组：[1, 2, 3]  ， 字符串："abc"  ，
                         数值（整数和浮点数）：12.34  ， 布尔值：true或false  ， 空值：null
    例子：
        // 反序列化操作!!
        InputStream input44 = Main.class.getClassLoader().getResourceAsStream("book.json");
        // ObjectMapper mapper44 = new ObjectMapper();
        // 要把JSON的某些值解析为特定的Java对象，例如LocalDate，需要 JavaTimeModule()
        ObjectMapper mapper44 = new ObjectMapper().registerModule(new JavaTimeModule());
        // 反序列化时忽略不存在的 javabean 属性
        mapper44.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);
        try {
            Book22 book44 = mapper44.readValue(input44, Book22.class);
            System.out.println(book44.id);
            System.out.println(book44.name);
            // 序列化操作!!
            String json = mapper44.writeValueAsString(book44);
            System.out.println(json);
        } catch (Exception e) {
            e.printStackTrace();
        }


2、日期与时间
    Java有两套日期和时间的API
        旧的API：Date、Calendar、TimeZone、SimpleDateFormat
        新的API：LocalDateTime、ZonedDateTime、ZoneId、DateTimeFormatter
        区别：新API严格区分了时刻、本地日期、本地时间和带时区的日期时间，并且，对日期和时间进行运算更加方便

    Date
        例子：
            // 获取当前时间
            Date date = new Date();
            System.out.println(date.getYear() + 1900);  // 2022
            System.out.println(date.getMonth() + 1);    // 6
            System.out.println(date.getDate());         // 16
            // 转换为String
            System.out.println(date.toString());        // Thu Jun 16 21:32:05 CST 2022
            // 转换为GMT时区
            System.out.println(date.toGMTString());     // 16 Jun 2022 13:32:05 GMT
            // 转换为本地时区
            System.out.println(date.toLocaleString());  // 2022年6月16日下午9:32:05
            // 日期格式化
            var sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
            System.out.println(sdf.format(date));       // 2022-06-16 21:32:05

    Calendar
        概念：Calendar 和 Date 比，主要多了一个可以做简单的日期和时间运算的功能，提供了时区转换的功能，时区用TimeZone对象表示。
        例子：
            // 获取当前时间
            Calendar c = Calendar.getInstance();
            int y = c.get(Calendar.YEAR);           // 年
            int m = 1 + c.get(Calendar.MONTH);      // 月
            int d = c.get(Calendar.DAY_OF_MONTH);   // 天
            int w = c.get(Calendar.DAY_OF_WEEK);    // 周  1~7 分别表示周日，周一 ... 周六
            int hh = c.get(Calendar.HOUR_OF_DAY);   // 小时
            int mm = c.get(Calendar.MINUTE);        // 分钟
            int ss = c.get(Calendar.SECOND);        // 秒
            int ms = c.get(Calendar.MILLISECOND);   // 毫秒
            System.out.println(c.getTime());        // Calendar对象转换成Date对象， Thu Jun 16 21:32:05 CST 2022
            System.out.println(y + "-" + m + "-" + d + " " + w + " " + hh + ":" + mm + ":" + ss + "." + ms);  // 2022-6-16 5 21:32:5.734
            c.set(Calendar.YEAR, 2020);             // 设置时间
            System.out.println(new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").format(c.getTime()));  // 2020-06-16 21:32:05
            // 重置时间到最初值
            c.clear();
            c.set(Calendar.YEAR, 2019);
            System.out.println(new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").format(c.getTime()));  // 2019-01-01 00:00:00

            // 用 TimeZone 对象来对 Calender 对象进行转换
            TimeZone tzDefault = TimeZone.getDefault();
            TimeZone tzGMT7 = TimeZone.getTimeZone("GMT+07:00");
            System.out.println(tzDefault); // sun.util.calendar.ZoneInfo[id="Asia/Shanghai",offset=28800000,dstSavings=0,useDaylight=false,transitions=31,lastRule=null]
            System.out.println(tzGMT7);    // sun.util.calendar.ZoneInfo[id="GMT+07:00",offset=25200000,dstSavings=0,useDaylight=false,transitions=0,lastRule=null]
            c.clear();
            // 设置年月日时分秒
            c.set(2019, 10, 20, 1, 15, 0);
            // 格式化时间
            var sdf22 = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
            sdf22.setTimeZone(TimeZone.getTimeZone("GMT+11:00"));
            System.out.println(sdf22.format(c.getTime()));  // 2019-11-20 04:15:00

    LocalDateTime
        概念：可以表示一个本地时间
        例子：
            // 当前日期
            LocalDate d2 = LocalDate.now();
            // 当前时间
            LocalTime t2 = LocalTime.now();
            // 当前日期和时间
            LocalDateTime ldt2 = LocalDateTime.now();
            System.out.println(d2 + " ==== " + t2 + " ==== " + ldt2);   // 2022-06-16 ==== 21:32:05.740769 ==== 2022-06-16T21:32:05.740786
            // 显示指定的日期和时间
            LocalDate d3 = LocalDate.of(2019, 11, 30);
            LocalTime t3 = LocalTime.of(15, 16, 17);
            LocalDateTime ldt3 = LocalDateTime.of(2019, 11, 30, 15, 16, 17);
            System.out.println(d3 + " ==== " + t3 + " ==== " + ldt3);   // 2019-11-30 ==== 15:16:17 ==== 2019-11-30T15:16:17
            // 解析日期
            LocalDateTime ldt4 = LocalDateTime.parse("2019-11-19T15:16:17");
            LocalDate d4 = LocalDate.parse("2019-11-19");
            LocalTime t4 = LocalTime.parse("15:16:17");
            System.out.println(ldt4 + " ==== " + d4 + " ==== " + t4);   // 2019-11-19T15:16:17 ==== 2019-11-19 ==== 15:16:17

    ZonedDateTime
        概念：时区计算
        例子：
            // 简单地把 ZonedDateTime 理解成 LocalDateTime 加 ZoneId
            // 获取默认时区时间
            ZonedDateTime zbj = ZonedDateTime.now();
            System.out.println(zbj);    // 2022-06-16T21:32:05.743941+08:00[Asia/Shanghai]
            // 将时间转换到指定时区
            ZonedDateTime zny = ZonedDateTime.now(ZoneId.of("America/New_York"));
            System.out.println(zny);    // 2022-06-16T09:32:05.744843-04:00[America/New_York]
            // 显示指定时区下的指定时间
            LocalDateTime ldt = LocalDateTime.of(2019, 9, 15, 15, 16, 17);
            ZonedDateTime zbj22 = ldt.atZone(ZoneId.systemDefault());
            System.out.println(zbj22); // 2019-09-15T15:16:17+08:00[Asia/Shanghai]
            ZonedDateTime zny22 = ldt.atZone(ZoneId.of("America/New_York"));
            System.out.println(zny22); // 2019-09-15T15:16:17-04:00[America/New_York]

    DateTimeFormatter
        概念：格式化时间
        例子：
            DateTimeFormatter dft5 = DateTimeFormatter.ofPattern("yyyy/MM/dd HH:mm:ss");
            System.out.println(dft5.format(LocalDateTime.now()));       // 2022/06/16 21:32:05
            LocalDateTime ldt5 = LocalDateTime.parse("2019/11/29 13:12:11", dft5);
            System.out.println(ldt5);           // 2019-11-29T13:12:11
            // 日期加减
            LocalDateTime ldt6 = LocalDateTime.of(2019, 10, 26, 20, 30, 59);
            LocalDateTime ldt611 = ldt6.plusDays(6).minusHours(3);
            System.out.println(ldt611);         // 2019-11-01T17:30:59
            LocalDateTime ldt622 = ldt6.minusMonths(1);
            System.out.println(ldt622);         // 2019-09-26T20:30:59
            // 重置日期
            //     调整年：withYear()   调整月：withMonth()     调整日：withDayOfMonth()
            //     调整时：withHour()   调整分：withMinute()    调整秒：withSecond()
            LocalDateTime ldt7 = LocalDateTime.of(2019, 10, 26, 20, 30, 59);
            LocalDateTime ldt711 = ldt7.withDayOfMonth(31);
            System.out.println(ldt711);             // 2019-10-31T20:30:59
            // 本月第一天0:00
            LocalDateTime firstDay = LocalDate.now().withDayOfMonth(1).atStartOfDay();
            System.out.println(firstDay);           // 2022-06-01T00:00
            // 本月最后1天
            LocalDate lastDay = LocalDate.now().with(TemporalAdjusters.lastDayOfMonth());
            System.out.println(lastDay);            // 2022-06-30
            // 下月第1天
            LocalDate nextMonthFristDay = LocalDate.now().with(TemporalAdjusters.firstDayOfNextMonth());
            System.out.println(nextMonthFristDay);  // 2022-07-01
            // 本月第1个周一
            LocalDate firstWeekday = LocalDate.now().with(TemporalAdjusters.firstInMonth(DayOfWeek.MONDAY));
            System.out.println(firstWeekday);       // 2022-06-06
            // 日期比较
            LocalDateTime target = LocalDateTime.of(2019, 11, 19, 8, 15, 0);
            System.out.println(LocalDateTime.now().isBefore(target));   // false
            System.out.println(LocalDateTime.now().isAfter(target));    // true

    Instant
        概念：获取时间戳
        例子：
            Instant now = Instant.now();
            // 显示秒
            System.out.println(now.getEpochSecond());   // 1655386325
            // 显示秒和毫秒
            System.out.println(now.toEpochMilli());     // 1655386325745
            // 时间戳转换时区时间
            Instant ins = Instant.ofEpochSecond(1654401791);
            ZonedDateTime zdt3 = ins.atZone(ZoneId.systemDefault());
            System.out.println(zdt3);       // 2022-06-05T12:03:11+08:00[Asia/Shanghai]


3、使用 Stream
    概念：Stream 代表的是任意Java对象的序列
         Stream 输出的元素并没有预先存储在内存中，而是实时计算出来的。
         Stream 类似于一个泛型
    例子：
        // 创建 stream
        // 基于数组或Collection
        Stream<String> stream11 = Stream.of("A", "B", "C", "D");
        Stream<String> stream22 = Arrays.stream(new String[] {"A", "B", "C"});
        Stream<String> stream33 = List.of("X", "Y", "Z").stream();
        stream11.forEach(System.out::print);    // ABCD
        stream22.forEach(System.out::print);    // ABC
        stream33.forEach(System.out::print);    // XYZ
        // 基于Supplier 不断产生下一个元素
        Stream<Integer> natural = Stream.generate(new NaturalSupplier());
        natural.limit(8).forEach(System.out::print);   // 1 2 3 4 5 6 7 8
        class NaturalSupplier implements Supplier {
            int n = 0;
            public Integer get() {
                n++;
                return n;
            }
        }
        // 把字符串分割成Stream序列而不是数组
        Pattern p = Pattern.compile("\\s+");
        Stream<String> s = p.splitAsStream("His hair had a natural curl");
        s.forEach(System.out::print);   // Hishairhadanaturalcurl
        // Java的范型不支持基本类型，所以我们无法用Stream<int>这样的类型，所以用 IntStream LongStream 等等
        IntStream is = Arrays.stream(new int[] {1, 2, 3});
        LongStream ls = List.of("1", "3", "5").stream().mapToLong(Long::parseLong);
        is.forEach(System.out::print);  // 123
        ls.forEach(System.out::print);  // 135

        // map  将一个Stream的每个元素转换成另一个元素
        List.of(" Apple ", " pEar", " orAnge ", "  bAnana   ").stream().map(String::trim).map(String::toLowerCase).forEach(System.out::print);  // applepearorangebanana

        // filter  过滤元素
        Stream.generate(new LocalDateSupplier()).limit(31)
                .filter(ldt22 -> ldt22.getDayOfWeek() == DayOfWeek.SATURDAY || ldt22.getDayOfWeek() == DayOfWeek.SUNDAY)
                .forEach(System.out::print); // 2022-06-04 2022-06-05 2022-06-11 2022-06-12 2022-06-18 2022-06-19 2022-06-25 2022-06-26 2022-07-02

        // reduce  把一个Stream的所有元素按照聚合函数聚合成一个结果
        System.out.println();
        System.out.println("reduce");
        int sum = Stream.of(1, 2, 3, 4, 5, 6, 7, 8).reduce(0, (acc, n) -> acc + n);  // 36
        System.out.println(sum);
        // 按行读取文件
        List<String> props = List.of("profile=native", "debug=true", "logging=warn", "interval=500");
        Map<String, String> map110 = props.stream().map(kv -> {
            String[] ss110 = kv.split("\\=", 2);
            return Map.of(ss110[0], ss110[1]);
        }).reduce(new HashMap<String, String>(), (m110, kv) -> {
            m110.putAll(kv);
            return m110;
        });
        map110.forEach((k, v) -> {
            System.out.println(k + " = " + v);  // logging = warn  interval = 500  debug = true  profile = native
        });

        // 输出集合
        // 输出为List
        Stream<String> stream44 = Stream.of("Apple", "", null, "Pear", "  ", "Orange");
        List<String> list44 = stream44.filter(s44 -> s44 != null && !s44.isBlank()).collect(Collectors.toList());
        System.out.println(list44);     // [Apple, Pear, Orange]
        // 输出为数组
        List<String> list55 = List.of("Apple", "Banana", "Orange");
        String[] array55 = list55.stream().toArray(String[]::new);
        for(String arr:array55) {
            System.out.println(arr);    // Apple  Banana  Orange
        }
        // 输出为Map
        Stream<String> stream66 = Stream.of("appL:apple", "msft1:microsoft");
        Map<String, String> map66 = stream66.collect(Collectors.toMap(
                s6 -> s6.substring(0, s6.indexOf(":")), s6 -> s6.substring(s6.indexOf(":")+1)
        ));
        System.out.println(map66);  // {appL=apple, msft1=microsoft}
        // 分组输出
        List<String> list77 = List.of("Apple", "Banana", "Blackberry", "Coconut", "Avocado", "Cherry", "Apricots");
        Map<String, List<String>> groups = list77.stream().collect(Collectors.groupingBy(
                s77 -> s77.substring(0, 1), Collectors.toList()
        ));
        System.out.println(groups); // {A=[Apple, Avocado, Apricots], B=[Banana, Blackberry], C=[Coconut, Cherry]}

        // 其它操作
        // 综合使用
        ArrayList<Integer> l = new ArrayList<Integer>();
        for (int i = 1; i < 1000; i++) {
            l.add(i);
        }
        Stream<Integer> naturals = l.stream().filter(n -> n % 2 == 0).map(n -> n - 1).limit(10);
        naturals.forEach(System.out::print);    // 1 3 5 7 9 11 13 15 17 19
        // 排序
        List<String> list88 = List.of("Orange", "apple", "Banana").stream().sorted().collect(Collectors.toList());
        System.out.println(list88); // [Banana, Orange, apple]
        // 去重
        List<String> list99 = List.of("A", "B", "A", "C", "B", "D").stream().distinct().collect(Collectors.toList());
        System.out.println(list99); // [A, B, C, D]
        // 截取
        List<String> list100 = List.of("A", "B", "C", "D", "E", "F").stream().skip(2).limit(3).collect(Collectors.toList());
        System.out.println(list100); // [C, D, E]
        // 合并
        Stream<String> s110 = List.of("A", "B", "C").stream();
        Stream<String> s111 = List.of("A", "Y", "X").stream();
        Stream<String> s112 = Stream.concat(s110, s111);
        System.out.println(s112.collect(Collectors.toList()));  // [A, B, C, A, Y, X]
        // flatMap  把Stream的每个元素（下面的例子是List）映射为Stream，然后合并成一个新的Stream
        Stream<List<Integer>> s120 = Stream.of(
                Arrays.asList(1, 2, 3),
                Arrays.asList(4, 5, 6),
                Arrays.asList(7, 8, 9)
        );
        Stream<Integer> i120 = s120.flatMap(list -> list.stream());
        i120.forEach(System.out::print);    // 123456789

        // 转换操作：map()，filter()，sorted()，distinct()；
        // 合并操作：concat()，flatMap()；
        // 并行处理：parallel()；
        // 聚合操作：reduce()，collect()，count()，max()，min()，sum()，average()；
        // 其他操作：allMatch(), anyMatch(), forEach()


4、IO
    File 对象
        例子：
            System.out.println(File.separator);     // /
            // Windows平台。  假设当前目录是C:\Docs
            // .表示当前目录，  ..表示上级目录
            File f1 = new File("sub\\javac");     // 绝对路径是C:\Docs\sub\javac
            File f2 = new File(".\\sub\\javac");  // 绝对路径是C:\Docs\sub\javac
            File f3 = new File("..\\sub\\javac"); // 绝对路径是C:\sub\javac
            try {
                File f4 = new File("..");
                System.out.println(f4.getPath());   // ..
                System.out.println(f4.getAbsolutePath());  //  /Applications/XAMPP/xamppfiles/htdocs/my_practice22/my_java/yyyy/..
                System.out.println(f4.getCanonicalPath()); //  /Applications/XAMPP/xamppfiles/htdocs/my_practice22/my_java
            } catch (IOException e) {
                e.printStackTrace();
            }
            File f5 = new File("/Applications/XAMPP/xamppfiles/htdocs/my_practice22/my_java");
            File f6 = new File("/Applications/XAMPP/xamppfiles/htdocs/my_practice22/my_java/yyyy/pom.xml");
            System.out.println(f5.isFile());        // false
            System.out.println(f5.isDirectory());   // true
            System.out.println(f6.isFile());        // true
            System.out.println(f6.isDirectory());   // false
            // boolean  canRead()：是否可读；
            // boolean  canWrite()：是否可写；
            // boolean  canExecute()：是否可执行；
            // long     length()：文件字节大小

            File f7 = new File("/Applications/XAMPP/xamppfiles/htdocs/my_practice22/my_java/yyyy/mmm.txt");
            try {
                // 创建、删除文件
                if (f7.createNewFile()) {
                    System.out.println("创建文件成功");   // 创建文件成功
                    if (f7.delete()) {
                        System.out.println("删除文件成功");   // 删除文件成功
                    }
                }
                // 创建临时文件
                File f8 = File.createTempFile("tmp-", ".txt");
                f8.deleteOnExit();      // JVM退出时自动删除
                System.out.println(f8.isFile());           // true
                System.out.println(f8.getAbsolutePath());  // /var/folders/c1/rwz_lt052_bgfn7zx4yr14q40000gn/T/tmp-14969864616872664021.txt
            } catch (IOException e) {
                e.printStackTrace();
            }

            // 遍历文件和目录
            static void printFiles(File[] files) {
                if (files != null) {
                    for (File f : files) {
                        System.out.println(f);
                    }
                }
            }
            File f9 = new File("/Applications/XAMPP/xamppfiles/htdocs/my_practice22/my_java/yyyy");
            File[] fs1 = f9.listFiles();
            printFiles(fs1);
            //   /Applications/XAMPP/xamppfiles/htdocs/my_practice22/my_java/yyyy/testFiles
            //   /Applications/XAMPP/xamppfiles/htdocs/my_practice22/my_java/yyyy/mvnw.cmd
            //   /Applications/XAMPP/xamppfiles/htdocs/my_practice22/my_java/yyyy/config
            //   /Applications/XAMPP/xamppfiles/htdocs/my_practice22/my_java/yyyy/target
            // 过滤文件和目录
            File[] fs2 = f9.listFiles(new FilenameFilter() {
                @Override
                public boolean accept(File dir, String name) {
                    return name.endsWith(".xml");
                }
            });
            printFiles(fs2);   //  /Applications/XAMPP/xamppfiles/htdocs/my_practice22/my_java/yyyy/pom.xml
            // boolean mkdir()：   File对象如果表示一个目录，创建目录；
            // boolean mkdirs()：  File对象如果表示一个目录，将不存在的父目录也创建出来；
            // boolean delete()：  File对象如果表示一个目录，删除当前目录，但当前目录必须为空。

    InputStream & OutputStream
        概念：IO流以byte（字节）为最小单位，因此也称为字节流
             InputStream代表输入字节流，OuputStream代表输出字节流，这是最基本的两种IO流
        例子：
            // InputStream
            // 写法一
            InputStream input10 = null;
            try {
                input10 = new FileInputStream("testFiles/ttt.txt");
                for(;;) {
                    int n = input10.read();
                    // 反复调用read()方法，直到返回-1
                    if (n == -1) {
                        break;
                    }
                    // 输出的是 ascii 码值
                    // System.out.println(n);
                }
                input10.close();
            } catch (IOException e) {
                e.printStackTrace();
            }

            // 写法二
            // try(resource)的语法，只需要编写try语句，让编译器自动为我们关闭资源。
            try (InputStream input11 = new FileInputStream("testFiles/ttt.txt")) {
                int n;
                while ((n = input11.read()) != -1) {
                    // 输出的是 ascii 码值
                    System.out.println(n);
                }
            } catch (IOException e) {
                e.printStackTrace();
            }

            // 利用缓冲区一次读取多个字节
            try (InputStream input12 = new FileInputStream("testFiles/ttt22.txt")) {
                byte[] buffer = new byte[1000];
                int n;
                while ((n = input12.read(buffer)) != -1) {
                    System.out.println("read " + n + " bytes....");
                    // read 1000 bytes....
                    // read 1000 bytes....
                    // read 483 bytes....
                }
            } catch (IOException e) {
                e.printStackTrace();
            }

            String s13;
            try (InputStream input13 = new FileInputStream("testFiles/ttt22.txt")) {
                int n;
                StringBuilder sb13 = new StringBuilder();
                while ((n = input13.read()) != -1) {
                    sb13.append((char) n);
                }
                s13 = sb13.toString();
                System.out.println(s13);    // 输入 txt 内容，但是中文是乱码 ？？？
            } catch (IOException e) {
                e.printStackTrace();
            }

            // FileOutputStream
            try {
                OutputStream output11 = new FileOutputStream("testFiles/ttt33.txt");
                output11.write(72);  // h
                output11.write(101); // e
                output11.write(108); // l
                output11.write(108); // l
                output11.write(111); // o
                output11.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
            // 一次性写入多个字节
            try (OutputStream output12 = new FileOutputStream("testFiles/ttt44.txt")) {
                output12.write("Hello121212".getBytes("UTF-8"));
            } catch (IOException e) {
                e.printStackTrace();
            }

    Reader & Writer
        概念：按照char来读写显然更方便，这种流称为字符流
             Reader和Writer表示字符流，字符流传输的最小数据单位是char
             究竟使用Reader还是InputStream，要取决于具体的使用场景。如果数据源不是文本，就只能使用InputStream，
                如果数据源是文本，使用Reader更方便一些。Reader和Writer本质上是一个能自动编解码的InputStream和OutputStream
        例子：
            // Reader
            // InputStream是一个字节流，即以byte为单位读取，而Reader是一个字符流，即以char为单位读取
            try (Reader reader = new FileReader("testFiles/ttt22.txt", StandardCharsets.UTF_8)) {
                for (;;) {
                    int n = reader.read();
                    if (n == -1) {
                        break;
                    }
                    System.out.print((char)n);  // 输出 txt 内容，无中文乱码
                }
                // reader.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
            // 一次性读取若干字符
            try (Reader reader = new FileReader("testFiles/ttt22.txt", StandardCharsets.UTF_8)) {
                char[] buffer = new char[500];
                int n;
                while ((n = reader.read(buffer)) != -1) {
                    System.out.println("read " + n + " chars.");
                    // read 500 chars.
                    // read 500 chars.
                    // read 175 chars.
                }
            } catch (IOException e) {
                e.printStackTrace();
            }

            // Writer
            try (Writer writer = new FileWriter("testFiles/ttt55.txt", StandardCharsets.UTF_8)) {
                writer.write("H");
                writer.write("Job".toCharArray()); // 写入char[]
                writer.write(" candidate=");
            } catch (IOException e) {
                e.printStackTrace();
            }

    使用Files
        概念：Files 封装了很多读写文件的方法，简化了读写操作。
        注意：Files提供的读写方法，受内存限制，只能读写小文件，例如配置文件等，不可一次读入几个G的大文件。
        例子：
            // 读写大型文件仍然要使用文件流，每次只读写一部分文件内容
            try {
                // 读
                byte[] data13 = Files.readAllBytes(Path.of("testFiles/ttt66.txt"));
                System.out.println(data13[0]);    // ASCII码 116
                System.out.println("-----------");
                String content13 = Files.readString(Path.of("testFiles/ttt66.txt"), StandardCharsets.UTF_8);
                System.out.println(content13);    // 输入全部 txt 内容，没有中文乱码
                System.out.println("-----------");
                List<String> lines = Files.readAllLines(Path.of("testFiles/ttt66.txt"));
                System.out.println(lines.get(0)); // 输入 txt 内容的第一行
                System.out.println("-----------");
                // 写
                byte[] data14 = {56, 57, 98};
                Files.write(Path.of("testFiles/ttt77_1.txt"), data14);  // 将 ASCII 码转换为字符
                Files.writeString(Path.of("testFiles/ttt77_2.txt"), "文档内容 lalaa", StandardCharsets.UTF_8);
                List<String> lines14 = List.of("咯咯咯咯", "upset");    // 输入中英文，无乱码
                Files.write(Path.of("testFiles/ttt77_3.txt"), lines14);     // 输入中英文，无乱码
            } catch (IOException e) {
                e.printStackTrace();
            }


5、正则表达式
    基础匹配
        基础用法：
            匹配特殊字符，用 \ 转义。  例如：a\&c 匹配 a&c
            匹配一个任意字符，用 .
            匹配 0 ~ 9 这样的单个数字，用 \d 。
            匹配一个字母、数字或下划线，用 \w 。   但 \w 不能匹配#、空格等字符
            匹配一个空格字符、tab字符（在Java中用\t表示），用 \s
            匹配一个非数字，用 \D。   \W  \S 也是以此类推
            匹配任意个字符，包括0个、1个、多个字符，用 *。  例如：\d*
            匹配至少一个字符，用 + 。      例如：\d+
            匹配0个或一个字符，用 ? 。
            精确匹配指定个字符，用 {n}, {m, n}, {n,}
            指定Unicode字符 \u548c，匹配汉字 "和"
        例子：
            String regex11 = "20\\d\\d";
            System.out.println("2019".matches(regex11) + " " + "2100".matches(regex11));  // true false
            String regex22 = "abc";
            System.out.println("abc".matches(regex22) + " " + "Abc".matches(regex22) + " " + "abcd".matches(regex22));  // true false false
            // 对应的正则是a\&c
            String regex33 = "a\\&c";
            System.out.println("a&c".matches(regex33) + " " + "a-c".matches(regex33) + " " + "a&&c".matches(regex33)); // true false false
            String regex44 = "java\\d";
            System.out.println("java9".matches(regex44) + " " + "java10".matches(regex44) + " " + "javac".matches(regex44)); // true false false
            String regex55 = "java\\D";
            System.out.println("javax".matches(regex55) + " " + "java#".matches(regex55) + " " + "java5".matches(regex55)); // true true false

    复杂匹配
        基础用法：
            ^表示匹配开头，$表示匹配结尾。
            匹配指定范围，用 []。 例如：[0-9a-fA-F]
            规则匹配，用 | 。 例如： AB|CD
            使用括号把公共部分提取出来，用 learn\\s(java|php|go)，等同于 learn\sjava|learn\sphp|learn\sgo
            匹配指定范围外的任意字符，用 [^]。 例如：[^A-F]
        例子：
            // 复杂匹配
            String regex66 = "java|php";
            System.out.println("java".matches(regex66) + " " + "php".matches(regex66) + " " + "go".matches(regex66));  // true true false
            String regex77 = "learn\\s(java|php|go)";
            System.out.println("learn java".matches(regex77) + " " + "learn php".matches(regex77) + " " + "learn Java".matches(regex77));  // true true false

    分组匹配&提取
        高级用法：
            匹配 区号-电话号码，用 \d{3,4}\-\d{6,8}。 如果要提取号码，用 (\d{3,4})\-(\d{6,8})
        例子：
            // 分组匹配&提取
            Pattern pat11 = Pattern.compile("(\\d{3,4})\\-(\\d{7,8})");
            Matcher mat11 = pat11.matcher("010-12345678");
            if (mat11.matches()) {
                String g0 = mat11.group(0);
                String g1 = mat11.group(1);
                String g2 = mat11.group(2);
                System.out.println(g0 + " | " + g1 + " | " + g2);   // 010-12345678 | 010 | 12345678
            } else {
                System.out.println("匹配失败");
            }
            Matcher mat11_22 = pat11.matcher("021-123456");
            System.out.println(mat11_22.matches());  // false
            Matcher mat11_33 = pat11.matcher("022#1234567");
            System.out.println(mat11_33.matches());  // false

    非贪婪匹配
        高级用法：
            正则表达式默认使用贪婪匹配：任何一个规则，它总是尽可能多地向后匹配。
            在规则后面加个?即可表示非贪婪匹配，比如： \d+?
        例子：
            // 非贪婪匹配
            Pattern pat22 = Pattern.compile("(\\d+)(0*)");
            Matcher mat22 = pat22.matcher("1230000");
            if (mat22.matches()) {
                System.out.println("group1=" + mat22.group(1));     // group1=1230000
                System.out.println("group2=" + mat22.group(2));     // group2=
            }
            Pattern pat33 = Pattern.compile("(\\d+?)(0*)");
            Matcher mat33 = pat33.matcher("1230000");
            if (mat33.matches()) {
                System.out.println("group1=" + mat33.group(1));     // group1=123
                System.out.println("group2=" + mat33.group(2));     // group2=0000
            }

    搜索和替换
        例子：
            // 分割字符串
            String[] arr44 = "a b c".split("\\s");
            for(String val44:arr44) {
                System.out.println("arr44: " + val44);
                // arr44: a
                // arr44: b
                // arr44: c
            }
            String[] arr55 = "a b  c".split("\\s");
            for(String val55:arr55) {
                System.out.println("arr55: " + val55);
                // arr55: a
                // arr55: b
                // arr55:
                // arr55: c
            }
            String[] arr66 = "a, b ;; c".split("[\\,\\;\\s]+");
            for(String val66:arr66) {
                System.out.println("arr66: " + val66);
                // arr66: a
                // arr66: b
                // arr66: c
            }
            // 搜索字符串
            String str77 = "the quick brown fox jumps over the lazy dog.";
            Pattern pat77 = Pattern.compile("\\wo\\w");
            Matcher mat77 = pat77.matcher(str77);
            while(mat77.find()) {
                String sub = str77.substring(mat77.start(), mat77.end());
                System.out.println(mat77.start() + " " + mat77.end() + " " + sub);
                // 11 14 row
                // 16 19 fox
                // 40 43 dog
            }
            // 替换字符串
            String str88 = "The     quick\\t\\t     brown   fox  jumps   over the  lazy dog.";
            String r88 = str88.replaceAll("\\s+", " ");
            System.out.println(r88);  // The quick\t\t brown fox jumps over the lazy dog.
            // 反向引用
            String str99 = "the quick brown fox jumps over the lazy dog.";
            String r99 = str99.replaceAll("\\s([a-z]{4})\\s", " <b>$1</b> ");
            System.out.println(r99);  // the quick brown fox jumps <b>over</b> the <b>lazy</b> dog.


6、Maven基础
    概念：Maven 是专门为Java项目打造的管理和构建工具
         Maven Wrapper 就是给一个项目A提供一个独立的，指定版本的Maven，供A使用。
            另一个作用是把项目的mvnw、mvnw.cmd和.mvn提交到版本库中，可以使所有开发人员使用统一的Maven版本

    Maven标准目录介绍：
        ① 项目描述文件pom.xml
            格式如下：
                <project ...>
                    <modelVersion>4.0.0</modelVersion>
                    <groupId>com.itranswarp.learnjava</groupId>
                    <artifactId>hello</artifactId>
                    <version>1.0</version>
                    <packaging>jar</packaging>
                    <properties>
                        ...
                    </properties>
                    <dependencies>
                        <dependency>
                            <groupId>commons-logging</groupId>
                            <artifactId>commons-logging</artifactId>
                            <version>1.2</version>
                            <scope>compile</scope>
                        </dependency>
                    </dependencies>
                </project>

            标签介绍：
                groupId类似于Java的包名，通常是公司或组织名称
                artifactId类似于Java的类名，通常是项目名称
                一个Maven工程就是由groupId，artifactId，version作为唯一标识。引用第三方库时，就是通过这3个变量来确定
                scope 依赖关系
                    compile：默认的也是最常用的，Maven会把这种类型的依赖直接放入classpath。比如，commons-logging
                    test：依赖表示仅在测试时使用，正常运行时并不需要。最常用的test依赖就是JUnit
                    runtime：编译时不需要，但运行时需要。最典型的runtime依赖是JDBC驱动
                    provided：编译时需要，但运行时不需要。最典型的provided依赖是Servlet API，编译的时候需要，但是运行时，Servlet服务器内置了相关的jar，所以运行期不需要

        ② 存放Java源码的目录是 src/main/java
        ③ 存放资源文件的目录是 src/main/resources
        ④ 存放测试源码的目录是 src/test/java
        ⑤ 存放测试资源的目录是 src/test/resources
        ⑥ 所有编译、打包生成的文件都放在 target 目录里

    命令：
        mvn -version    // 查看Maven的版本信息

    Maven镜像：
        在用户主目录下进入.m2目录，创建一个settings.xml配置文件
        不希望把源码和jar包放到公网上，那么可以搭建私有仓库，在本地的 家目录/.m2/settings.xml中配置好
        <settings>
            <mirrors>
                <mirror>
                    <id>aliyun</id>
                    <name>aliyun</name>
                    <mirrorOf>central</mirrorOf>
                    <!-- 国内推荐阿里云的Maven镜像 -->
                    <url>https://maven.aliyun.com/repository/central</url>
                </mirror>
            </mirrors>
        </settings>


7、单元测试
    基础JUnit
        // 精度问题，浮点数无法精确地进行比较
        @Test
        void testFact() {
            assertEquals(1, ZzzzApplicationTests.fact(1));
            assertEquals(2, ZzzzApplicationTests.fact(2));
            assertEquals(6, ZzzzApplicationTests.fact(3));
            // 浮点数无法精确地进行比较，因此我们需要调用 assertEquals 这个重载方法，指定一个误差值
            assertEquals(0.1, Math.abs(1 - 9/10.0), 0.0000001);
        }

    使用Fixture
        概念：JUnit提供了编写测试前准备、测试后清理的固定代码，我们称之为Fixture
             编写测试前准备、测试后清理的固定代码，我们称之为Fixture
        例子：
            public class Calculator {
                private long n = 0;

                public long add(long x) {
                    n = n + x;
                    return n;
                }
            }

            public class CalculatorTest {
                Calculator calculator;

                @BeforeEach
                public void setUp() {
                    this.calculator = new Calculator();
                }

                @AfterEach
                public void tearDown() {
                    this.calculator = null;
                }

                @Test
                void testAdd() {
                    assertEquals(100, this.calculator.add(100));
                }
            }

    异常测试
        public class Factorial {
            public static long fact22(long n) {
                if (n < 0) {
                    throw new IllegalArgumentException();
                }
                long r = 1;
                for (long i = 1; i <= n; i++) {
                    r = r * i;
                }
                return r;
            }
        }

        @Test
        void testNegative() {
            // 写法一
            assertThrows(IllegalArgumentException.class, new Executable() {
                @Override
                public void execute() throws Throwable {
                    Factorial.fact22(-1);
                }
            });

            // 写法二
            assertThrows(IllegalArgumentException.class, () -> {
                Factorial.fact22(-2);
            });
        }

    条件测试
        概念：JUnit根据不同的条件注解，决定是否运行当前的@Test方法，类似@Disabled这种注解就称为条件测试
        例子：
            // 条件测试
            @Test
            @Disabled("my_operation")
            void testOperation() {
                //  TODO: this test is disabled for bug fixing
            }

            @Test
            @EnabledOnOs(OS.WINDOWS)
            void testWindows() {
                assertEquals("C:\\test.ini", "C:\test.ini");
            }

            @Test
            @EnabledOnOs({OS.LINUX, OS.MAC})
            void testLiunxAndMac() {
                assertEquals("/usr/test.ini", "/usr/test.ini");
            }

    参数化测试
        概念：使用参数化测试，可以提供一组输入和输出的测试数据，对一个测试方法反复测试。
        例子：
            @ParameterizedTest
            @ValueSource(ints = {0, 1, 5, 100})
            void testAbs(int x) {
                assertEquals(x, Math.abs(x));
            }

            @ParameterizedTest
            @MethodSource
            void testCapitalize(String input, String result) {
                assertEquals(result, StringUtils.capitalize(input));
            }

            static List<Arguments> testCapitalize() {
                return List.of(
                        Arguments.of("abc", "Abc"),
                        Arguments.of("APPLE", "Apple"),
                        Arguments.of("gooD", "Good")
                );
            }

            @ParameterizedTest
            @CsvSource({"abc, Abc", "APPLE, Apple", "gooD, Good"})
            void testCapitalize22(String input, String result) {
                assertEquals(result, StringUtils.capitalize(input));
            }

            @ParameterizedTest
            @CsvFileSource(resources = {"/test-capitalize.csv"})
            void testCapitalize33(String input, String result) {
                assertEquals(result, StringUtils.capitalize(input));
            }


8、EJB

