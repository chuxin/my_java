1、XML 与 JSON
    Xml介绍：XML的这些相关技术实现起来非常复杂，在实际应用中很少用到，通常了解一下就可以了。
    例子：
        ① DOM：一次性读取XML，并在内存中表示为树形结构；
            // 在classpath中的资源文件，路径总是以／开头，我们先获取当前的Class对象，
            //   然后调用getResourceAsStream()就可以直接从classpath读取任意的资源文件
            InputStream input = Main.class.getClassLoader().getResourceAsStream("book.xml");
            DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
            try {
                DocumentBuilder db = dbf.newDocumentBuilder();
                Document doc = db.parse(input);
                printNode(doc, 0);
                // 0 Document: #document
                //  1 Element: book
                //   2 Text: #text =
                //
                //   2 Element: name
                //    3 Text: #text = Java核心技术
                //   2 Text: #text =
            } catch (Exception e) {
                e.printStackTrace();
            }

            // 这是一个递归
            static void printNode(Node n, int indent) {
                for (int i = 0; i < indent; i++) {
                    System.out.print(" ");
                }
                switch (n.getNodeType()) {
                    case Node.DOCUMENT_NODE:    // Document节点
                        System.out.println(indent + " Document: " + n.getNodeName());
                        break;
                    case Node.ELEMENT_NODE:     // 元素节点
                        System.out.println(indent + " Element: " + n.getNodeName());
                        break;
                    case Node.TEXT_NODE:    // 文本
                        System.out.println(indent + " Text: " + n.getNodeName() + " = " + n.getNodeValue());
                        break;
                    case Node.ATTRIBUTE_NODE:   // 属性
                        System.out.println(indent + " Attribute: " + n.getNodeName() + " = " + n.getNodeValue());
                        break;
                    case Node.CDATA_SECTION_NODE:
                        System.out.println(indent + " CDATA: " + n.getNodeName() + " = " + n.getNodeValue());
                        break;
                    case Node.COMMENT_NODE:
                        System.out.println(indent + " Comment: " + n.getNodeName() + " = " + n.getNodeValue());
                        break;
                    default:
                        System.out.println(indent + " NodeType: " + n.getNodeType() + ", NodeValue: " + n.getNodeValue());
                }
                for (Node child = n.getFirstChild(); child != null; child = child.getNextSibling()) {
                    printNode(child, indent + 1);
                }
            }

        ② SAX：以流的形式读取XML，使用事件回调。
            InputStream input22 = Main.class.getClassLoader().getResourceAsStream("book.xml");
            SAXParserFactory spf = SAXParserFactory.newInstance();
            try {
                SAXParser saxParserObj = spf.newSAXParser();
                saxParserObj.parse(input22, new MyHandler());
                // start document
                // start element:  book
                // characters:
                //
                // start element:  name
                // characters: Java核心技术
                // end element:  name
                // characters:
                //
                // end element:  book
                // end document
            } catch (Exception e) {
                e.printStackTrace();
            }

        ③ 使用Jackson
            public class Book {
                public long id;
                public String name;
                public String author;
                public String isbn;
                public List<String> tags;
                public String pubDate;
            }

            InputStream input33 = Main.class.getClassLoader().getResourceAsStream("book.xml");
            JacksonXmlModule module = new JacksonXmlModule();
            XmlMapper mapper = new XmlMapper(module);
            try {
                Book book = mapper.readValue(input33, Book.class);
                System.out.println(book.id);
                System.out.println(book.name);
            } catch (Exception e) {
                e.printStackTrace();
            }

    Json介绍：
        ① JSON只允许使用UTF-8编码，不存在编码问题
        ② 仅支持的数据类型：键值对：{"key": value}  ， 数组：[1, 2, 3]  ， 字符串："abc"  ，
                         数值（整数和浮点数）：12.34  ， 布尔值：true或false  ， 空值：null
    例子：
        // 反序列化操作!!
        InputStream input44 = Main.class.getClassLoader().getResourceAsStream("book.json");
        // ObjectMapper mapper44 = new ObjectMapper();
        // 要把JSON的某些值解析为特定的Java对象，例如LocalDate，需要 JavaTimeModule()
        ObjectMapper mapper44 = new ObjectMapper().registerModule(new JavaTimeModule());
        // 反序列化时忽略不存在的 javabean 属性
        mapper44.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);
        try {
            Book22 book44 = mapper44.readValue(input44, Book22.class);
            System.out.println(book44.id);
            System.out.println(book44.name);
            // 序列化操作!!
            String json = mapper44.writeValueAsString(book44);
            System.out.println(json);   // {"id":1,"name":"Java核心技术","author":"Cay S. Horstmann","isbn":9787111547426,"tags":["Java","Network"],"pubDate":[2016,9,1],"price":119.5}
        } catch (Exception e) {
            e.printStackTrace();
        }


2、日期与时间
    Java有两套日期和时间的API
        旧的API：Date、Calendar、TimeZone、SimpleDateFormat
        新的API：LocalDateTime、ZonedDateTime、ZoneId、DateTimeFormatter
        区别：新API严格区分了时刻、本地日期、本地时间和带时区的日期时间，并且，对日期和时间进行运算更加方便

    Date
        例子：
            // 获取当前时间
            Date date = new Date();
            System.out.println(date.getYear() + 1900);  // 2022
            System.out.println(date.getMonth() + 1);    // 6
            System.out.println(date.getDate());         // 16
            // 转换为String
            System.out.println(date.toString());        // Thu Jun 16 21:32:05 CST 2022
            // 转换为GMT时区
            System.out.println(date.toGMTString());     // 16 Jun 2022 13:32:05 GMT
            // 转换为本地时区
            System.out.println(date.toLocaleString());  // 2022年6月16日下午9:32:05
            // 日期格式化
            var sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
            System.out.println(sdf.format(date));       // 2022-06-16 21:32:05

    Calendar
        概念：Calendar 和 Date 比，主要多了一个可以做简单的日期和时间运算的功能，提供了时区转换的功能，时区用TimeZone对象表示。
        例子：
            // 获取当前时间
            Calendar c = Calendar.getInstance();
            int y = c.get(Calendar.YEAR);           // 年
            int m = 1 + c.get(Calendar.MONTH);      // 月
            int d = c.get(Calendar.DAY_OF_MONTH);   // 天
            int w = c.get(Calendar.DAY_OF_WEEK);    // 周  1~7 分别表示周日，周一 ... 周六
            int hh = c.get(Calendar.HOUR_OF_DAY);   // 小时
            int mm = c.get(Calendar.MINUTE);        // 分钟
            int ss = c.get(Calendar.SECOND);        // 秒
            int ms = c.get(Calendar.MILLISECOND);   // 毫秒
            System.out.println(c.getTime());        // Calendar对象转换成Date对象， Thu Jun 16 21:32:05 CST 2022
            System.out.println(y + "-" + m + "-" + d + " " + w + " " + hh + ":" + mm + ":" + ss + "." + ms);  // 2022-6-16 5 21:32:5.734
            c.set(Calendar.YEAR, 2020);             // 设置时间
            System.out.println(new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").format(c.getTime()));  // 2020-06-16 21:32:05
            // 重置时间到最初值
            c.clear();
            c.set(Calendar.YEAR, 2019);
            System.out.println(new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").format(c.getTime()));  // 2019-01-01 00:00:00

            // 用 TimeZone 对象来对 Calender 对象进行转换
            TimeZone tzDefault = TimeZone.getDefault();
            TimeZone tzGMT7 = TimeZone.getTimeZone("GMT+07:00");
            System.out.println(tzDefault); // sun.util.calendar.ZoneInfo[id="Asia/Shanghai",offset=28800000,dstSavings=0,useDaylight=false,transitions=31,lastRule=null]
            System.out.println(tzGMT7);    // sun.util.calendar.ZoneInfo[id="GMT+07:00",offset=25200000,dstSavings=0,useDaylight=false,transitions=0,lastRule=null]
            c.clear();
            // 设置年月日时分秒
            c.set(2019, 10, 20, 1, 15, 0);
            // 格式化时间
            var sdf22 = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
            sdf22.setTimeZone(TimeZone.getTimeZone("GMT+11:00"));
            System.out.println(sdf22.format(c.getTime()));  // 2019-11-20 04:15:00

    LocalDateTime
        概念：可以表示一个本地时间
        例子：
            // 当前日期
            LocalDate d2 = LocalDate.now();
            // 当前时间
            LocalTime t2 = LocalTime.now();
            // 当前日期和时间
            LocalDateTime ldt2 = LocalDateTime.now();
            System.out.println(d2 + " ==== " + t2 + " ==== " + ldt2);   // 2022-06-16 ==== 21:32:05.740769 ==== 2022-06-16T21:32:05.740786
            // 显示指定的日期和时间
            LocalDate d3 = LocalDate.of(2019, 11, 30);
            LocalTime t3 = LocalTime.of(15, 16, 17);
            LocalDateTime ldt3 = LocalDateTime.of(2019, 11, 30, 15, 16, 17);
            System.out.println(d3 + " ==== " + t3 + " ==== " + ldt3);   // 2019-11-30 ==== 15:16:17 ==== 2019-11-30T15:16:17
            // 解析日期   字符串转日期
            LocalDateTime ldt4 = LocalDateTime.parse("2019-11-19T15:16:17");
            LocalDate d4 = LocalDate.parse("2019-11-19");
            LocalTime t4 = LocalTime.parse("15:16:17");
            System.out.println(ldt4 + " ==== " + d4 + " ==== " + t4);   // 2019-11-19T15:16:17 ==== 2019-11-19 ==== 15:16:17

    ZonedDateTime
        概念：时区计算
        例子：
            // 简单地把 ZonedDateTime 理解成 LocalDateTime 加 ZoneId
            // 获取默认时区时间
            ZonedDateTime zbj = ZonedDateTime.now();
            System.out.println(zbj);    // 2022-06-16T21:32:05.743941+08:00[Asia/Shanghai]
            // 将时间转换到指定时区
            ZonedDateTime zny = ZonedDateTime.now(ZoneId.of("America/New_York"));
            System.out.println(zny);    // 2022-06-16T09:32:05.744843-04:00[America/New_York]
            // 显示指定时区下的指定时间
            LocalDateTime ldt = LocalDateTime.of(2019, 9, 15, 15, 16, 17);
            ZonedDateTime zbj22 = ldt.atZone(ZoneId.systemDefault());
            System.out.println(zbj22);  // 2019-09-15T15:16:17+08:00[Asia/Shanghai]
            ZonedDateTime zny22 = ldt.atZone(ZoneId.of("America/New_York"));
            System.out.println(zny22);  // 2019-09-15T15:16:17-04:00[America/New_York]

    DateTimeFormatter
        概念：格式化时间
        例子：
            DateTimeFormatter dft5 = DateTimeFormatter.ofPattern("yyyy/MM/dd HH:mm:ss");
            System.out.println(dft5.format(LocalDateTime.now()));       // 2022/06/16 21:32:05
            LocalDateTime ldt5 = LocalDateTime.parse("2019/11/29 13:12:11", dft5);
            System.out.println(ldt5);           // 2019-11-29T13:12:11
            // 日期加减
            LocalDateTime ldt6 = LocalDateTime.of(2019, 10, 26, 20, 30, 59);
            LocalDateTime ldt611 = ldt6.plusDays(6).minusHours(3);
            System.out.println(ldt611);         // 2019-11-01T17:30:59
            LocalDateTime ldt622 = ldt6.minusMonths(1);
            System.out.println(ldt622);         // 2019-09-26T20:30:59
            // 重置日期
            //     调整年：withYear()   调整月：withMonth()     调整日：withDayOfMonth()
            //     调整时：withHour()   调整分：withMinute()    调整秒：withSecond()
            LocalDateTime ldt7 = LocalDateTime.of(2019, 10, 26, 20, 30, 59);
            LocalDateTime ldt711 = ldt7.withDayOfMonth(31);
            System.out.println(ldt711);             // 2019-10-31T20:30:59
            // 本月第一天0:00
            LocalDateTime firstDay = LocalDate.now().withDayOfMonth(1).atStartOfDay();
            System.out.println(firstDay);           // 2022-06-01T00:00
            // 本月最后1天
            LocalDate lastDay = LocalDate.now().with(TemporalAdjusters.lastDayOfMonth());
            System.out.println(lastDay);            // 2022-06-30
            // 下月第1天
            LocalDate nextMonthFristDay = LocalDate.now().with(TemporalAdjusters.firstDayOfNextMonth());
            System.out.println(nextMonthFristDay);  // 2022-07-01
            // 本月第1个周一
            LocalDate firstWeekday = LocalDate.now().with(TemporalAdjusters.firstInMonth(DayOfWeek.MONDAY));
            System.out.println(firstWeekday);       // 2022-06-06
            // 日期比较
            LocalDateTime target = LocalDateTime.of(2019, 11, 19, 8, 15, 0);
            System.out.println(LocalDateTime.now().isBefore(target));   // false
            System.out.println(LocalDateTime.now().isAfter(target));    // true

    Instant
        概念：获取时间戳
        例子：
            Instant now = Instant.now();
            // 显示秒
            System.out.println(now.getEpochSecond());   // 1655386325
            // 显示秒和毫秒
            System.out.println(now.toEpochMilli());     // 1655386325745
            // 时间戳转换时区时间
            Instant ins = Instant.ofEpochSecond(1654401791);
            ZonedDateTime zdt3 = ins.atZone(ZoneId.systemDefault());
            System.out.println(zdt3);       // 2022-06-05T12:03:11+08:00[Asia/Shanghai]

    其它
        // 2022-07-01T23:59:59.900+08:00
        System.out.println(OffsetDateTime.of(LocalDate.of(2022, 7, 1), LocalTime.of(23, 59, 59, 900000000), ZoneOffset.ofHours(8)));

    遗留问题：
        LocalDateTime、 Date 、Calendar 、String 相互转换     https://blog.csdn.net/weixin_36158990/article/details/114170506
        日期大小比较
            Date自带方法before()和after()
            String的compareTo()
            转换为秒比较  getTime()

3、使用 Stream
    概念：Stream 代表的是任意Java对象的序列
         Stream 输出的元素并没有预先存储在内存中，而是实时计算出来的。
         Stream 类似于一个泛型
    例子：
        // 创建 stream
        // 基于数组或Collection
        Stream<String> stream11 = Stream.of("A", "B", "C", "D");
        Stream<String> stream22 = Arrays.stream(new String[] {"A", "B", "C"});
        Stream<String> stream33 = List.of("X", "Y", "Z").stream();
        stream11.forEach(System.out::print);    // ABCD
        stream22.forEach(System.out::print);    // ABC
        stream33.forEach(System.out::print);    // XYZ
        // 基于Supplier 不断产生下一个元素
        Stream<Integer> natural = Stream.generate(new NaturalSupplier());
        natural.limit(8).forEach(System.out::print);   // 1 2 3 4 5 6 7 8
        class NaturalSupplier implements Supplier {
            int n = 0;
            public Integer get() {
                n++;
                return n;
            }
        }
        // 把字符串分割成Stream序列而不是数组
        Pattern p = Pattern.compile("\\s+");
        Stream<String> s = p.splitAsStream("His hair had a natural curl");
        s.forEach(System.out::print);   // Hishairhadanaturalcurl
        // Java的范型不支持基本类型，所以我们无法用Stream<int>这样的类型，所以用 IntStream LongStream 等等
        IntStream is = Arrays.stream(new int[] {1, 2, 3});
        LongStream ls = List.of("1", "3", "5").stream().mapToLong(Long::parseLong);
        is.forEach(System.out::print);  // 123
        ls.forEach(System.out::print);  // 135

        // map  将一个Stream的每个元素转换成另一个元素
        List.of(" Apple ", " pEar", " orAnge ", "  bAnana   ").stream().map(String::trim).map(String::toLowerCase).forEach(System.out::print);  // applepearorangebanana

        // filter  过滤元素
        Stream.generate(new LocalDateSupplier()).limit(31)
                        .filter(ldt22 -> ldt22.getDayOfWeek() == DayOfWeek.SATURDAY || ldt22.getDayOfWeek() == DayOfWeek.SUNDAY)
                        .forEach(System.out::print); // 2022-06-04 2022-06-05 2022-06-11 2022-06-12 2022-06-18 2022-06-19 2022-06-25 2022-06-26 2022-07-02

        // reduce  把一个Stream的所有元素按照聚合函数聚合成一个结果
        System.out.println();
        System.out.println("reduce");
        int sum = Stream.of(1, 2, 3, 4, 5, 6, 7, 8).reduce(0, (acc, n) -> acc + n);  // 36
        System.out.println(sum);
        // 按行读取文件
        List<String> props = List.of("profile=native", "debug=true", "logging=warn", "interval=500");
        Map<String, String> map110 = props.stream().map(kv -> {
            String[] ss110 = kv.split("\\=", 2);
            return Map.of(ss110[0], ss110[1]);
        }).reduce(new HashMap<String, String>(), (m110, kv) -> {
            m110.putAll(kv);
            return m110;
        });
        map110.forEach((k, v) -> {
            System.out.println(k + " = " + v);  // logging = warn  interval = 500  debug = true  profile = native
        });

        // 输出集合
        // 输出为List
        Stream<String> stream44 = Stream.of("Apple", "", null, "Pear", "  ", "Orange");
        List<String> list44 = stream44.filter(s44 -> s44 != null && !s44.isBlank()).collect(Collectors.toList());
        System.out.println(list44);     // [Apple, Pear, Orange]

        public class Person {
            String name;
            public Person(String name) {
                this.name = name;
            }
            public String toString() {
                return "Person:" + this.name;
            }
        }
        // 方法①  把一个List<String>转换为List<Person>
        List<String> names = List.of("ee", "ff", "gg");
        List<Person> persons = new ArrayList<>();
        for (String name: names) {
            persons.add(new Person(name));
        }
        System.out.println(persons);
        // 方法②  把一个List<String>转换为List<Person>
        List<Person> persons2 = names.stream().map(Person::new).collect(Collectors.toList());
        System.out.println(persons2);

        // 输出为数组
        List<String> list55 = List.of("Apple", "Banana", "Orange");
        String[] array55 = list55.stream().toArray(String[]::new);
        for(String arr:array55) {
            System.out.println(arr);    // Apple  Banana  Orange
        }

        // 输出为Map
        Stream<String> stream66 = Stream.of("appL:apple", "msft1:microsoft");
        Map<String, String> map66 = stream66.collect(Collectors.toMap(
                s6 -> s6.substring(0, s6.indexOf(":")), s6 -> s6.substring(s6.indexOf(":")+1)
        ));
        System.out.println(map66);  // {appL=apple, msft1=microsoft}

        // 分组输出
        List<String> list77 = List.of("Apple", "Banana", "Blackberry", "Coconut", "Avocado", "Cherry", "Apricots");
        Map<String, List<String>> groups = list77.stream().collect(Collectors.groupingBy(
                s77 -> s77.substring(0, 1), Collectors.toList()
        ));
        System.out.println(groups); // {A=[Apple, Avocado, Apricots], B=[Banana, Blackberry], C=[Coconut, Cherry]}

        // 其它操作
        // 综合使用
        ArrayList<Integer> l = new ArrayList<Integer>();
        for (int i = 1; i < 1000; i++) {
            l.add(i);
        }
        Stream<Integer> naturals = l.stream().filter(n -> n % 2 == 0).map(n -> n - 1).limit(10);
        naturals.forEach(System.out::print);    // 1 3 5 7 9 11 13 15 17 19
        // 排序
        List<String> list88 = List.of("Orange", "apple", "Banana").stream().sorted().collect(Collectors.toList());
        System.out.println(list88); // [Banana, Orange, apple]     注意这几个单词的首字母大小写
        // 去重
        List<String> list99 = List.of("A", "B", "A", "C", "B", "D").stream().distinct().collect(Collectors.toList());
        System.out.println(list99); // [A, B, C, D]
        // 截取
        List<String> list100 = List.of("A", "B", "C", "D", "E", "F").stream().skip(2).limit(3).collect(Collectors.toList());
        System.out.println(list100); // [C, D, E]
        // 合并
        Stream<String> s110 = List.of("A", "B", "C").stream();
        Stream<String> s111 = List.of("A", "Y", "X").stream();
        Stream<String> s112 = Stream.concat(s110, s111);
        System.out.println(s112.collect(Collectors.toList()));  // [A, B, C, A, Y, X]
        // flatMap  把Stream的每个元素（下面的例子是List）映射为Stream，然后合并成一个新的Stream
        Stream<List<Integer>> s120 = Stream.of(
                Arrays.asList(1, 2, 3),
                Arrays.asList(4, 5, 6),
                Arrays.asList(7, 8, 9)
        );
        Stream<Integer> i120 = s120.flatMap(list -> list.stream());
        i120.forEach(System.out::print);    // 123456789

        // 转换操作：map()，filter()，sorted()，distinct()；
        // 合并操作：concat()，flatMap()；
        // 并行处理：parallel()；
        // 聚合操作：reduce()，collect()，count()，max()，min()，sum()，average()；
        // 其他操作：allMatch(), anyMatch(), forEach()


4、IO
    File 对象
        例子：
            System.out.println(File.separator);     // /
            // Windows平台。  假设当前目录是C:\Docs
            // .表示当前目录，  ..表示上级目录
            File f1 = new File("sub\\javac");     // 绝对路径是C:\Docs\sub\javac
            File f2 = new File(".\\sub\\javac");  // 绝对路径是C:\Docs\sub\javac
            File f3 = new File("..\\sub\\javac"); // 绝对路径是C:\sub\javac
            try {
                File f4 = new File("..");
                System.out.println(f4.getPath());   // ..
                System.out.println(f4.getAbsolutePath());  //  /Applications/XAMPP/xamppfiles/htdocs/my_practice22/my_java/yyyy/..
                System.out.println(f4.getCanonicalPath()); //  /Applications/XAMPP/xamppfiles/htdocs/my_practice22/my_java
            } catch (IOException e) {
                e.printStackTrace();
            }
            File f5 = new File("/Applications/XAMPP/xamppfiles/htdocs/my_practice22/my_java");
            File f6 = new File("/Applications/XAMPP/xamppfiles/htdocs/my_practice22/my_java/yyyy/pom.xml");
            System.out.println(f5.isFile());        // false
            System.out.println(f5.isDirectory());   // true
            System.out.println(f6.isFile());        // true
            System.out.println(f6.isDirectory());   // false
            // boolean  canRead()：是否可读；
            // boolean  canWrite()：是否可写；
            // boolean  canExecute()：是否可执行；
            // long     length()：文件字节大小

            File f7 = new File("/Applications/XAMPP/xamppfiles/htdocs/my_practice22/my_java/yyyy/mmm.txt");
            try {
                // 创建、删除文件
                if (f7.createNewFile()) {
                    System.out.println("创建文件成功");   // 创建文件成功
                    if (f7.delete()) {
                        System.out.println("删除文件成功");   // 删除文件成功
                    }
                }
                // 创建临时文件
                File f8 = File.createTempFile("tmp-", ".txt");
                f8.deleteOnExit();      // JVM退出时自动删除
                System.out.println(f8.isFile());           // true
                System.out.println(f8.getAbsolutePath());  // /var/folders/c1/rwz_lt052_bgfn7zx4yr14q40000gn/T/tmp-14969864616872664021.txt
            } catch (IOException e) {
                e.printStackTrace();
            }

            // 遍历文件和目录
            static void printFiles(File[] files) {
                if (files != null) {
                    for (File f : files) {
                        System.out.println(f);
                    }
                }
            }
            File f9 = new File("/Applications/XAMPP/xamppfiles/htdocs/my_practice22/my_java/yyyy");
            File[] fs1 = f9.listFiles();
            printFiles(fs1);
            //   /Applications/XAMPP/xamppfiles/htdocs/my_practice22/my_java/yyyy/testFiles
            //   /Applications/XAMPP/xamppfiles/htdocs/my_practice22/my_java/yyyy/mvnw.cmd
            //   /Applications/XAMPP/xamppfiles/htdocs/my_practice22/my_java/yyyy/config
            //   /Applications/XAMPP/xamppfiles/htdocs/my_practice22/my_java/yyyy/target
            // 过滤文件和目录
            File[] fs2 = f9.listFiles(new FilenameFilter() {
                @Override
                public boolean accept(File dir, String name) {
                    return name.endsWith(".xml");
                }
            });
            printFiles(fs2);   //  /Applications/XAMPP/xamppfiles/htdocs/my_practice22/my_java/yyyy/pom.xml
            // boolean mkdir()：   File对象如果表示一个目录，创建目录；
            // boolean mkdirs()：  File对象如果表示一个目录，将不存在的父目录也创建出来；
            // boolean delete()：  File对象如果表示一个目录，删除当前目录，但当前目录必须为空。

    InputStream & OutputStream
        概念：IO流以byte（字节）为最小单位，因此也称为字节流
             InputStream代表输入字节流，OuputStream代表输出字节流，这是最基本的两种IO流
        例子：
            // InputStream
            // 写法一
            InputStream input10 = null;
            try {
                input10 = new FileInputStream("testFiles/ttt.txt");
                for(;;) {
                    int n = input10.read();
                    // 反复调用read()方法，直到返回-1
                    if (n == -1) {
                        break;
                    }
                    // 输出的是 ascii 码值
                    // System.out.println(n);
                }
                input10.close();
            } catch (IOException e) {
                e.printStackTrace();
            }

            // 写法二
            // try(resource)的语法，只需要编写try语句，让编译器自动为我们关闭资源。
            try (InputStream input11 = new FileInputStream("testFiles/ttt.txt")) {
                int n;
                while ((n = input11.read()) != -1) {
                    // 输出的是 ascii 码值
                    System.out.println(n);
                }
            } catch (IOException e) {
                e.printStackTrace();
            }

            // 利用缓冲区一次读取多个字节
            try (InputStream input12 = new FileInputStream("testFiles/ttt22.txt")) {
                byte[] buffer = new byte[1000];
                int n;
                while ((n = input12.read(buffer)) != -1) {
                    System.out.println("read " + n + " bytes....");
                    // read 1000 bytes....
                    // read 1000 bytes....
                    // read 483 bytes....
                }
            } catch (IOException e) {
                e.printStackTrace();
            }

            String s13;
            try (InputStream input13 = new FileInputStream("testFiles/ttt22.txt")) {
                int n;
                StringBuilder sb13 = new StringBuilder();
                while ((n = input13.read()) != -1) {
                    sb13.append((char) n);
                }
                s13 = sb13.toString();
                System.out.println(s13);    // 输入 txt 内容，但是中文是乱码 ？？？
            } catch (IOException e) {
                e.printStackTrace();
            }

            // FileOutputStream
            try {
                OutputStream output11 = new FileOutputStream("testFiles/ttt33.txt");
                output11.write(72);  // h
                output11.write(101); // e
                output11.write(108); // l
                output11.write(108); // l
                output11.write(111); // o
                output11.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
            // 一次性写入多个字节
            try (OutputStream output12 = new FileOutputStream("testFiles/ttt44.txt")) {
                output12.write("Hello121212".getBytes("UTF-8"));
            } catch (IOException e) {
                e.printStackTrace();
            }

    Reader & Writer
        概念：按照char来读写显然更方便，这种流称为字符流
             Reader和Writer表示字符流，字符流传输的最小数据单位是char
             究竟使用Reader还是InputStream，要取决于具体的使用场景。如果数据源不是文本，就只能使用InputStream，
                如果数据源是文本，使用Reader更方便一些。Reader和Writer本质上是一个能自动编解码的InputStream和OutputStream
        例子：
            // Reader
            // InputStream是一个字节流，即以byte为单位读取，而Reader是一个字符流，即以char为单位读取
            try (Reader reader = new FileReader("testFiles/ttt22.txt", StandardCharsets.UTF_8)) {
                for (;;) {
                    int n = reader.read();
                    if (n == -1) {
                        break;
                    }
                    System.out.print((char)n);  // 输出 txt 内容，无中文乱码
                }
                // reader.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
            // 一次性读取若干字符
            try (Reader reader = new FileReader("testFiles/ttt22.txt", StandardCharsets.UTF_8)) {
                char[] buffer = new char[500];
                int n;
                while ((n = reader.read(buffer)) != -1) {
                    System.out.println("read " + n + " chars.");
                    // read 500 chars.
                    // read 500 chars.
                    // read 175 chars.
                }
            } catch (IOException e) {
                e.printStackTrace();
            }

            // Writer
            try (Writer writer = new FileWriter("testFiles/ttt55.txt", StandardCharsets.UTF_8)) {
                writer.write("H");
                writer.write("Job".toCharArray()); // 写入char[]
                writer.write(" candidate=");
            } catch (IOException e) {
                e.printStackTrace();
            }

    使用Files
        概念：Files 封装了很多读写文件的方法，简化了读写操作。
        注意：Files提供的读写方法，受内存限制，只能读写小文件，例如配置文件等，不可一次读入几个G的大文件。
        例子：
            // 读写大型文件仍然要使用文件流，每次只读写一部分文件内容
            try {
                // 读
                byte[] data13 = Files.readAllBytes(Path.of("testFiles/ttt66.txt"));
                System.out.println(data13[0]);    // ASCII码 116
                System.out.println("-----------");
                String content13 = Files.readString(Path.of("testFiles/ttt66.txt"), StandardCharsets.UTF_8);
                System.out.println(content13);    // 输入全部 txt 内容，没有中文乱码
                System.out.println("-----------");
                List<String> lines = Files.readAllLines(Path.of("testFiles/ttt66.txt"));
                System.out.println(lines.get(0)); // 输入 txt 内容的第一行
                System.out.println("-----------");
                // 写
                byte[] data14 = {56, 57, 98};
                Files.write(Path.of("testFiles/ttt77_1.txt"), data14);  // 将 ASCII 码转换为字符
                Files.writeString(Path.of("testFiles/ttt77_2.txt"), "文档内容 lalaa", StandardCharsets.UTF_8);
                List<String> lines14 = List.of("咯咯咯咯", "upset");    // 输入中英文，无乱码
                Files.write(Path.of("testFiles/ttt77_3.txt"), lines14);     // 输入中英文，无乱码
            } catch (IOException e) {
                e.printStackTrace();
            }


5、正则表达式
    基础匹配
        基础用法：
            匹配特殊字符，用 \ 转义。  例如：a\&c 匹配 a&c
            匹配一个任意字符，用 .
            匹配 0 ~ 9 这样的单个数字，用 \d 。
            匹配一个字母、数字或下划线，用 \w 。   但 \w 不能匹配#、空格等字符
            匹配一个空格字符、tab字符（在Java中用\t表示），用 \s
            匹配一个非数字，用 \D。   \W  \S 也是以此类推
            匹配任意个字符，包括0个、1个、多个字符，用 *。  例如：\d*
            匹配至少一个字符，用 + 。      例如：\d+
            匹配0个或一个字符，用 ? 。
            精确匹配指定个字符，用 {n}, {m, n}, {n,}
            指定Unicode字符 \u548c，匹配汉字 "和"
        例子：
            String regex11 = "20\\d\\d";
            System.out.println("2019".matches(regex11) + " " + "2100".matches(regex11));  // true false
            String regex22 = "abc";
            System.out.println("abc".matches(regex22) + " " + "Abc".matches(regex22) + " " + "abcd".matches(regex22));  // true false false
            // 对应的正则是a\&c
            String regex33 = "a\\&c";
            System.out.println("a&c".matches(regex33) + " " + "a-c".matches(regex33) + " " + "a&&c".matches(regex33)); // true false false
            String regex44 = "java\\d";
            System.out.println("java9".matches(regex44) + " " + "java10".matches(regex44) + " " + "javac".matches(regex44)); // true false false
            String regex55 = "java\\D";
            System.out.println("javax".matches(regex55) + " " + "java#".matches(regex55) + " " + "java5".matches(regex55)); // true true false

    复杂匹配
        基础用法：
            ^表示匹配开头，$表示匹配结尾。
            匹配指定范围，用 []。 例如：[0-9a-fA-F]
            规则匹配，用 | 。 例如： AB|CD
            使用括号把公共部分提取出来，用 learn\\s(java|php|go)，等同于 learn\sjava|learn\sphp|learn\sgo
            匹配指定范围外的任意字符，用 [^]。 例如：[^A-F]
        例子：
            // 复杂匹配
            String regex66 = "java|php";
            System.out.println("java".matches(regex66) + " " + "php".matches(regex66) + " " + "go".matches(regex66));  // true true false
            String regex77 = "learn\\s(java|php|go)";
            System.out.println("learn java".matches(regex77) + " " + "learn php".matches(regex77) + " " + "learn Java".matches(regex77));  // true true false

    分组匹配&提取
        高级用法：
            匹配 区号-电话号码，用 \d{3,4}\-\d{6,8}。 如果要提取号码，用 (\d{3,4})\-(\d{6,8})
        例子：
            // 分组匹配&提取
            Pattern pat11 = Pattern.compile("(\\d{3,4})\\-(\\d{7,8})");
            Matcher mat11 = pat11.matcher("010-12345678");
            if (mat11.matches()) {
                String g0 = mat11.group(0);
                String g1 = mat11.group(1);
                String g2 = mat11.group(2);
                System.out.println(g0 + " | " + g1 + " | " + g2);   // 010-12345678 | 010 | 12345678
            } else {
                System.out.println("匹配失败");
            }
            Matcher mat11_22 = pat11.matcher("021-123456");
            System.out.println(mat11_22.matches());  // false
            Matcher mat11_33 = pat11.matcher("022#1234567");
            System.out.println(mat11_33.matches());  // false

    非贪婪匹配
        高级用法：
            正则表达式默认使用贪婪匹配：任何一个规则，它总是尽可能多地向后匹配。
            在规则后面加个?即可表示非贪婪匹配，比如： \d+?
        例子：
            // 非贪婪匹配
            Pattern pat22 = Pattern.compile("(\\d+)(0*)");
            Matcher mat22 = pat22.matcher("1230000");
            if (mat22.matches()) {
                System.out.println("group1=" + mat22.group(1));     // group1=1230000
                System.out.println("group2=" + mat22.group(2));     // group2=
            }
            Pattern pat33 = Pattern.compile("(\\d+?)(0*)");
            Matcher mat33 = pat33.matcher("1230000");
            if (mat33.matches()) {
                System.out.println("group1=" + mat33.group(1));     // group1=123
                System.out.println("group2=" + mat33.group(2));     // group2=0000
            }

    搜索和替换
        例子：
            // 分割字符串
            String[] arr44 = "a b c".split("\\s");
            for(String val44:arr44) {
                System.out.println("arr44: " + val44);
                // arr44: a
                // arr44: b
                // arr44: c
            }
            String[] arr55 = "a b  c".split("\\s");
            for(String val55:arr55) {
                System.out.println("arr55: " + val55);
                // arr55: a
                // arr55: b
                // arr55:
                // arr55: c
            }
            String[] arr66 = "a, b ;; c".split("[\\,\\;\\s]+");
            for(String val66:arr66) {
                System.out.println("arr66: " + val66);
                // arr66: a
                // arr66: b
                // arr66: c
            }
            // 搜索字符串
            String str77 = "the quick brown fox jumps over the lazy dog.";
            Pattern pat77 = Pattern.compile("\\wo\\w");
            Matcher mat77 = pat77.matcher(str77);
            while(mat77.find()) {
                String sub = str77.substring(mat77.start(), mat77.end());
                System.out.println(mat77.start() + " " + mat77.end() + " " + sub);
                // 11 14 row
                // 16 19 fox
                // 40 43 dog
            }
            // 替换字符串
            String str88 = "The     quick\\t\\t     brown   fox  jumps   over the  lazy dog.";
            String r88 = str88.replaceAll("\\s+", " ");
            System.out.println(r88);  // The quick\t\t brown fox jumps over the lazy dog.
            // 反向引用
            String str99 = "the quick brown fox jumps over the lazy dog.";
            String r99 = str99.replaceAll("\\s([a-z]{4})\\s", " <b>$1</b> ");
            System.out.println(r99);  // the quick brown fox jumps <b>over</b> the <b>lazy</b> dog.


6、Maven基础
    概念：Maven 是专门为Java项目打造的管理和构建工具
         Maven Wrapper 就是给一个项目A提供一个独立的，指定版本的Maven，供A使用。
            另一个作用是把项目的mvnw、mvnw.cmd和.mvn提交到版本库中，可以使所有开发人员使用统一的Maven版本

    MAC 安装 mvn
        brew install mvn
        mvn --version
        mvn clean package   # 将项目打包
        # Maven 对项目进行打包时，位于项目根目录下的配置文件是无法被打包进项目的 JAR 包的，因此位于根目录下的默认配置文件无法在 JAR 中生效

    命令：
        mvn -version    // 查看Maven的版本信息

    Maven标准目录介绍：
        ① 项目描述文件pom.xml
            格式如下：
                <project ...>
                    <modelVersion>4.0.0</modelVersion>
                    <groupId>com.itranswarp.learnjava</groupId>
                    <artifactId>hello</artifactId>
                    <version>1.0</version>
                    <packaging>jar</packaging>
                    <properties>
                        ...
                    </properties>
                    <dependencies>
                        <dependency>
                            <groupId>commons-logging</groupId>
                            <artifactId>commons-logging</artifactId>
                            <version>1.2</version>
                            <scope>compile</scope>
                        </dependency>
                    </dependencies>
                </project>

            标签介绍：
                groupId类似于Java的包名，通常是公司或组织名称
                artifactId类似于Java的类名，通常是项目名称
                一个Maven工程就是由groupId，artifactId，version作为唯一标识。引用第三方库时，就是通过这3个变量来确定
                scope 依赖关系
                    compile：默认的也是最常用的，Maven会把这种类型的依赖直接放入classpath。比如，commons-logging
                    test：依赖表示仅在测试时使用，正常运行时并不需要。最常用的test依赖就是JUnit
                    runtime：编译时不需要，但运行时需要。最典型的runtime依赖是JDBC驱动
                    provided：编译时需要，但运行时不需要。最典型的provided依赖是Servlet API，编译的时候需要，但是运行时，Servlet服务器内置了相关的jar，所以运行期不需要

        ② 存放Java源码的目录是 src/main/java
        ③ 存放资源文件的目录是 src/main/resources
        ④ 存放测试源码的目录是 src/test/java
        ⑤ 存放测试资源的目录是 src/test/resources
        ⑥ 所有编译、打包生成的文件都放在 target 目录里

    Maven镜像：
        在用户主目录下进入.m2目录，创建一个settings.xml配置文件
        不希望把源码和jar包放到公网上，那么可以搭建私有仓库，在本地的 家目录/.m2/settings.xml中配置好
        <settings>
            <mirrors>
                <mirror>
                    <id>aliyun</id>
                    <name>aliyun</name>
                    <mirrorOf>central</mirrorOf>
                    <!-- 国内推荐阿里云的Maven镜像 -->
                    <url>https://maven.aliyun.com/repository/central</url>
                </mirror>
            </mirrors>
        </settings>


7、单元测试
    基础JUnit
        // 精度问题，浮点数无法精确地进行比较
        @Test
        void testFact() {
            assertEquals(1, ZzzzApplicationTests.fact(1));
            assertEquals(2, ZzzzApplicationTests.fact(2));
            assertEquals(6, ZzzzApplicationTests.fact(3));
            // 浮点数无法精确地进行比较，因此我们需要调用 assertEquals 这个重载方法，指定一个误差值
            assertEquals(0.1, Math.abs(1 - 9/10.0), 0.0000001);
        }

    使用Fixture
        概念：JUnit提供了编写测试前准备、测试后清理的固定代码，我们称之为Fixture
             编写测试前准备、测试后清理的固定代码，我们称之为Fixture
        例子：
            public class Calculator {
                private long n = 0;

                public long add(long x) {
                    n = n + x;
                    return n;
                }
            }

            public class CalculatorTest {
                Calculator calculator;

                @BeforeEach
                public void setUp() {
                    this.calculator = new Calculator();
                }

                @AfterEach
                public void tearDown() {
                    this.calculator = null;
                }

                @Test
                void testAdd() {
                    assertEquals(100, this.calculator.add(100));
                }
            }

    异常测试
        public class Factorial {
            public static long fact22(long n) {
                if (n < 0) {
                    throw new IllegalArgumentException();
                }
                long r = 1;
                for (long i = 1; i <= n; i++) {
                    r = r * i;
                }
                return r;
            }
        }

        @Test
        void testNegative() {
            // 写法一
            assertThrows(IllegalArgumentException.class, new Executable() {
                @Override
                public void execute() throws Throwable {
                    Factorial.fact22(-1);
                }
            });

            // 写法二
            assertThrows(IllegalArgumentException.class, () -> {
                Factorial.fact22(-2);
            });
        }

    条件测试
        概念：JUnit根据不同的条件注解，决定是否运行当前的@Test方法，类似@Disabled这种注解就称为条件测试
        例子：
            // 条件测试
            @Test
            @Disabled("my_operation")
            void testOperation() {
                //  TODO: this test is disabled for bug fixing
            }

            @Test
            @EnabledOnOs(OS.WINDOWS)
            void testWindows() {
                assertEquals("C:\\test.ini", "C:\test.ini");
            }

            @Test
            @EnabledOnOs({OS.LINUX, OS.MAC})
            void testLiunxAndMac() {
                assertEquals("/usr/test.ini", "/usr/test.ini");
            }

    参数化测试
        概念：使用参数化测试，可以提供一组输入和输出的测试数据，对一个测试方法反复测试。
        例子：
            @ParameterizedTest
            @ValueSource(ints = {0, 1, 5, 100})
            void testAbs(int x) {
                assertEquals(x, Math.abs(x));
            }

            @ParameterizedTest
            @MethodSource
            void testCapitalize(String input, String result) {
                assertEquals(result, StringUtils.capitalize(input));
            }

            static List<Arguments> testCapitalize() {
                return List.of(
                        Arguments.of("abc", "Abc"),
                        Arguments.of("APPLE", "Apple"),
                        Arguments.of("gooD", "Good")
                );
            }

            @ParameterizedTest
            @CsvSource({"abc, Abc", "APPLE, Apple", "gooD, Good"})
            void testCapitalize22(String input, String result) {
                assertEquals(result, StringUtils.capitalize(input));
            }

            @ParameterizedTest
            @CsvFileSource(resources = {"/test-capitalize.csv"})
            void testCapitalize33(String input, String result) {
                assertEquals(result, StringUtils.capitalize(input));
            }


8、EJB（Enterprise JavaBean）
    概念：将业务逻辑从客户端软件中抽取出来，封装在一个组件中。
         这个组件运行在一个独立的服务器上，
         客户端软件通过网络调用组件提供的服务以实现业务逻辑，而客户端软件的功能单纯到只负责发送调用请求和显示处理结果。
         这个运行在一个独立的服务器上，并封装了业务逻辑的组件就是EJB组件

    大白话解释：把你编写的软件中那些需要执行制定的任务的类，不放到客户端软件上了，而是给他打成包放到一个服务器上了

    实现技术：客户端是通过 远程对象调用的技术RMI 调用 运行在独立服务器上的EJB组件。
            在RMI之下的网络细节，如：TCP 和Socket 等等无需关注

    服务器集群：通过RMI的通信，连接不同功能模块的服务器，以实现一个完整的功能。


9、反射（Reflection）
    概念：反射是为了解决在运行期，对某个实例一无所知的情况下，如何调用其方法。
         通过Class实例获取class信息的方法称为反射。


10、多线程
    概念：多线程是Java最基本的一种并发模型
         一个Java程序实际上是一个JVM进程，JVM进程用一个主线程来执行main()方法，在main()方法内部，我们又可以启动多个线程。
             此外，JVM还有负责垃圾回收的其他工作线程等

    多线程编程特点：
        多线程经常需要读写共享数据
        线程需要同步
        复杂度高，调试困难

    实现多任务的方法：
        ① 多进程模式（每个进程只有一个线程）
        ② 多线程模式（一个进程有多个线程）
        ③ 多进程＋多线程模式（复杂度最高）

    进程 vs 线程
        多进程的优点：
            多进程稳定性比多线程高，因为在多进程的情况下，一个进程崩溃不会影响其他进程，而在多线程的情况下，任何一个线程崩溃会直接导致整个进程崩溃
        多进程的缺点：
            创建进程比创建线程开销大，尤其是在Windows系统上；
            进程间通信比线程间通信要慢，因为线程间通信就是读写同一个变量，速度很快。

    创建线程
        注意：
            一个线程对象只能调用一次start()方法；
            线程的执行代码写在run()方法中；
            线程调度由操作系统决定，程序本身无法决定哪个线程先执行完，哪个后执行完；
        例子：
            // 最简单的多线程。这个线程启动后实际上什么也不做就立刻结束了
            Thread t = new Thread();
            t.start();

            // 方法① 从Thread派生一个自定义类
            class MyThread22 extends Thread {
                @Override
                public void run() {
                    System.out.println("start second new thread");
                }
            }
            Thread t2 = new MyThread22();
            // 注意：直接调用 run 方法不会启动新线程
            t2.start();     // start second new thread

            // 方法② 创建Thread实例时，传入一个Runnable实例
            Thread t3 = new Thread(new MyRunnable());
            t3.start();     // start third new thread

            // 方法③ 用 lambda 语法进一步简化
            Thread t4 = new Thread(() -> {
                System.out.println("start fourth new thread");
            });
            t4.start();     // start fourth new thread

    线程的状态
        状态清单：
            New：新创建的线程，尚未执行；
            Runnable：运行中的线程，正在执行run()方法的Java代码；
            Blocked：运行中的线程，因为某些操作被阻塞而挂起；
            Waiting：运行中的线程，因为某些操作在等待中；
            Timed Waiting：运行中的线程，因为执行sleep()方法正在计时等待；
            Terminated：线程已终止，因为run()方法执行完毕。

        状态流转顺序：new -> Runnable、Blocked、Waiting、Timed Waiting 线程在四种状态间来回切换 -> Terminated

        线程终止的原因
            线程正常终止：run()方法执行到return语句返回；
            线程意外终止：run()方法因为未捕获的异常导致线程终止；
            对某个线程的Thread实例调用stop()方法强制终止（强烈不推荐使用）

        例子：
            // 通过t5.join()等待t5线程结束后再继续运行，此时 t5.join()会让main线程进入等待状态
            Thread t5 = new Thread(() -> {
                System.out.println("hello join");
            });
            t5.start();     // hello join
            try {
                t5.join();
            } catch (InterruptedException e) {}
            System.out.println("55 main end");  // 55 main end

            // 中断线程
            // 最常见的功能就是下载，用户下载了一个 10G 的文件，网络太慢，用户等得不耐烦，下载过程中点 取消 按钮
            // ① 使用 interrupt
            // 例子一
            class MyThread66 extends Thread {
                @Override
                public void run() {
                    int n = 0;
                    // 调用interrupt()方法可以请求中断一个线程
                    // 通过 isInterrupted() 检测自身是否需要中断
                    while (! isInterrupted()) {
                        n++;
                        System.out.println(n + " Thread66");
                    }
                }
            }
            Thread t6 = new MyThread66();
            t6.start();
            // 1 Thread66
            // 2 Thread66
            // ...
            // 117 Thread66
            try {
                Thread.sleep(1);    // 暂停1毫秒
                t6.interrupt();     // 中断t6线程
                t6.join();          // 等待t6线程结束
            } catch (InterruptedException e) {}
            System.out.println("66 main end");  // 66 main end

            // 例子二
            // interrupt 终止 join 的等待，让 join 中的线程立马结束运行
            class HelloThread extends Thread {
                public void run() {
                    int n = 0;
                    while(!isInterrupted()) {
                        n++;
                        System.out.println(n + " helloThread");
                        try {
                            Thread.sleep(100);
                        } catch (InterruptedException e) {
                            break;
                        }
                    }
                }
            }
            class MyThread77 extends Thread {
                public void run() {
                    Thread hello = new HelloThread();
                    hello.start();
                    // 1 helloThread
                    // 2 helloThread
                    // ...
                    // 10 helloThread
                    try {
                        // 外层调用 t7.interrupt() 此句，让这里做了捕获，并结束 MyThread77 线程
                        hello.join();
                    } catch (InterruptedException e) {
                        System.out.println("MyThread77 interrupted!");  // MyThread77 interrupted!
                    }
                    // 如果去掉这一行代码，可以发现hello线程仍然会继续运行，且JVM不会退出
                    // 所以这里也要手动的结束 HelloThread 线程
                    hello.interrupt();
                }
            }
            Thread t7 = new MyThread77();
            t7.start();
            try {
                Thread.sleep(1000);
                t7.interrupt();
                t7.join();
            } catch (InterruptedException e) {}
            System.out.println("77 main end");  // 77 main end

            // ② 使用 running 标志位来作判断
            class HelloThread88 extends Thread {
                // volatile 关键字请看下面一节的解释
                public volatile boolean running = true;
                public void run() {
                    int n = 0;
                    while(running) {
                        n++;
                        System.out.println(n + " HelloThread88");
                    }
                    System.out.println("HelloThread88 end");
                }
            }
            HelloThread88 t8 = new HelloThread88();
            t8.start();
            // 1 HelloThread88
            // 2 HelloThread88
            // ...
            // 129 HelloThread88
            // HelloThread88 end
            try {
                Thread.sleep(1);
            } catch (InterruptedException e) {}
            t8.running = false;

    Java的内存模型
        概念：在Java虚拟机中，变量的值保存在主内存中，但是，当线程访问变量时，它会先获取一个副本，并保存在自己的工作内存中。
             如果线程修改了变量的值，虚拟机会在某个时刻把修改后的值回写到主内存，但是，这个时间是不确定的！
             这会导致如果一个线程更新了某个变量，另一个线程读取的值可能还是更新前的。这就造成了多线程之间共享的变量不一致。

         解决办法：
            volatile关键字的目的是告诉虚拟机：① 每次访问变量时，总是获取主内存的最新值；② 每次修改变量后，立刻回写到主内存。
            volatile关键字让变量在线程间及时共享最新值

    守护线程(Daemon Thread)
        概念：守护线程是指为其他线程服务的线程。在JVM中，所有非守护线程都执行完毕后，无论有没有守护线程，虚拟机都会自动退出。
             守护线程的目的就是无限循环，类似于一个定时触发任务的线程。
        注意：守护线程不能持有任何需要关闭的资源，例如打开文件等，因为虚拟机退出时，守护线程没有任何机会来关闭文件，这会导致数据丢失。

        例子：
            class TimerThread extends Thread {
                @Override
                public void run() {
                    while(true) {
                        System.out.println("守护进程：" + LocalTime.now());
                        try {
                            Thread.sleep(1000);
                        } catch (InterruptedException e) {
                            break;
                        }
                    }
                }
            }
            Thread t9 = new TimerThread();
            t9.setDaemon(true);
            // t9.start();
            // 守护进程：11:16:47.479045
            // 守护进程：11:16:48.483682
            // ...

    线程同步
        概念：多线程同时读写共享变量时，会造成脏读，因此需要通过synchronized同步
             同步的本质就是给指定对象加锁，加锁后才能继续执行后续代码；

        线程安全(thread-safe):
            如果一个类被设计为允许多线程正确访问，我们就说这个类就是“线程安全”的，比如：java.lang.StringBuffer
            还有一些不变类，例如String，Integer，LocalDate，它们的所有成员变量都是final，多线程同时访问时只能读不能写，这些不变类也是线程安全的。
            类似Math这些只提供静态方法，没有成员变量的类，也是线程安全的。

        非线程安全：大部分类，例如ArrayList，都是非线程安全的。

        例子：
            // 例子一，没有 synchronized
            class AddThread10 extends Thread {
                public void run() {
                    for (int i = 0; i < 10000; i++) {
                        Counter.count += 1;
                    }
                }
            }
            class DecThread10 extends Thread {
                public void run() {
                    for (int i = 0; i < 10000; i++) {
                        Counter.count -= 1;
                    }
                }
            }
            var add10 = new AddThread10();
            var dec10 = new DecThread10();
            try {
                add10.start();
                dec10.start();
                add10.join();
                dec10.join();
            } catch (InterruptedException e) {}
            System.out.println(Counter.count);  // -7528 每次打印的数字都不是 0，因为加减过程中读取count变量存在脏读

            // 例子二，有 synchronized
            class Counter12 {
                private int count12 = 0;

                // synchronized 加锁，写法一
                public void add12(int n) {
                    synchronized(this) {
                        count12 += n;
                    }
                }

                // synchronized 加锁，写法二
                public synchronized void dec12(int n) {
                    count12 -= n;
                }

                public int get() {
                    return count12;
                }
            }
            var counter12_AA = new Counter12();
            var counter12_BB = new Counter12();
            Thread t12_add = new Thread(() -> {
                int tmp1 = 1;
                while (tmp1 <= 2000) {
                    tmp1++;
                    counter12_AA.add12(2);
                    counter12_BB.add12(4);
                }
            });
            Thread t12_dec = new Thread(() -> {
                int tmp2 = 1;
                while (tmp2 <= 2000) {
                    tmp2++;
                    counter12_AA.dec12(1);
                    counter12_BB.dec12(2);
                }
            });
            try {
                t12_add.start();
                t12_add.join();
                t12_dec.start();
                t12_dec.join();
            } catch (InterruptedException e) {}
            System.out.println(counter12_AA.get());     // 2000
            System.out.println(counter12_BB.get());     // 4000

    可重入的锁
        概念：JVM允许同一个线程重复获取同一个锁，这种能被同一个线程反复获取的锁，就叫做可重入锁。
             获取锁的时候，不但要判断是否是第一次获取，还要记录这是第几次获取。
                 每获取一次锁，记录+1，每退出synchronized块，记录-1，减到0的时候，才会真正释放锁。

    死锁
        概念：死锁产生的条件是多线程各自持有不同的锁，并互相试图获取对方已持有的锁，导致无限等待；
             避免死锁的方法是多线程获取锁的顺序要一致。

    多线程协调
        概念：多个线程间如何协调的运行。
             synchronized解决了多线程竞争的问题，使用wait和notify 解决多线程协调的问题
        原则：当条件不满足时，线程进入等待状态；当条件满足时，线程被唤醒，继续执行任务。

        例子：
            // 下面的例子，创建一个线程把10条数据放入 队列，创建 5 个消费线程，用来消费队列。 等待 100 毫秒，中断这 5 个消费线程
            class TaskQueue13 {
                Queue<String> queue = new LinkedList<>();

                public synchronized void addTask(String s) {
                    this.queue.add(s);
                    // 使用notifyAll()一次性全部唤醒所有当前正在this锁等待的线程
                    // 唤醒后，首先要等待执行addTask()的线程结束此方法后，才能释放this锁，随后，这3个线程中只能有一个获取到this锁，剩下两个将继续等待。
                    this.notifyAll();
                }

                public synchronized String doTask() throws InterruptedException {
                    while (queue.isEmpty()) {
                        // wait()方法必须在当前获取的锁对象上调用(即在synchronized方法中被调用)，这里获取的是this锁，因此调用this.wait()
                        // 调用wait()方法后，线程进入等待状态，wait()方法不会返回，直到被其他线程唤醒后，wait()方法才会返回，然后继续执行下一条语句。
                        // 当一个线程在this.wait()等待时，它就会释放this锁，从而使得其他线程能够在addTask()方法获得this锁
                        // await()会释放当前锁，进入等待状态；
                        this.wait();
                    }
                    // 用 while 不用 if 的原因
                    // 其中一个线程拿到了锁顺利执行，剩下的线程如果获取this锁后执行queue.remove()，此刻队列可能已经没有任何元素了。
                    return queue.remove();
                }
            }
            var q13 = new TaskQueue13();
            var arrT13 = new ArrayList<Thread>();
            for (int i = 0; i < 5; i++) {
                var t13 = new Thread() {
                    public void run() {
                        // 执行 task
                        while(true) {
                            try {
                                String doS13 = q13.doTask();
                                System.out.println("execute task: " + doS13);
                            } catch (InterruptedException e) {
                                return ;
                            }
                        }
                    }
                };
                t13.start();    // execute task: t13-0.5130567154490466
                arrT13.add(t13);
            }
            var add13 = new Thread(() -> {
                for (int i = 0; i < 10; i++) {
                    // 放入 task
                    String addS13 = "t13-" + Math.random();
                    System.out.println("add task: " + addS13);
                    q13.addTask(addS13);
                    try {
                        Thread.sleep(100);
                    } catch (InterruptedException e) {}
                }
            });
            add13.start();  // add task: t13-0.5130567154490466
            try {
                add13.join();
                Thread.sleep(100);
            } catch (InterruptedException e) {}
            for (var tmp13:arrT13) {
                tmp13.interrupt();
            }

    另一套多线程编码
        ReentrantLock：ReentrantLock用于替代synchronized加锁，另外有尝试机制。
                       ReentrantLock可以替代synchronized进行同步
                       java.util.concurrent包简化多线程程序的编写

        Condition：使用Condition对象来实现wait和notify的功能

        例子：
            class TaskQueue14 {
                private final Lock lock = new ReentrantLock();
                private final Condition condition = lock.newCondition();
                private Queue<String> queue = new LinkedList<>();

                public void addTask(String s) {
                    lock.lock();
                    try {
                        queue.add(s);
                        condition.signalAll();
                    } finally {
                        lock.unlock();
                    }
                }

                public String doTask() {
                    lock.lock();
                    try {
                        while (queue.isEmpty()) {
                            try {
                                condition.await();
                            } catch (InterruptedException e) {}
                        }
                        return queue.remove();
                    } finally {
                        lock.unlock();
                    }
                }
            }
            var q14 = new TaskQueue14();
            var arrT14 = new ArrayList<Thread>();
            for (int i = 0; i < 5; i++) {
                var t14 = new Thread() {
                    public void run() {
                        // 执行 task
                        while(true) {
                            String doS14 = q14.doTask();
                            System.out.println("execute task: " + doS14);
                        }
                    }
                };
                t14.start();    // execute task: t14-0.41502147849420756
                arrT14.add(t14);
            }
            var add14 = new Thread(() -> {
                for (int i = 0; i < 10; i++) {
                    // 放入 task
                    String addS14 = "t14-" + Math.random();
                    System.out.println("add task: " + addS14);
                    q14.addTask(addS14);
                    try {
                        Thread.sleep(100);
                    } catch (InterruptedException e) {}
                }
            });
            add14.start();  // add task: t14-0.41502147849420756
            try {
                add14.join();
                Thread.sleep(100);
            } catch (InterruptedException e) {}
            for (var tmp14:arrT14) {
                tmp14.interrupt();
            }

    ReadWriteLock(特殊场景)
        概念：用于解决一个特殊场景，只允许一个线程写入，允许多个线程在没有写入时同时读取，适合读多写少的场景。
        场景：一个论坛的帖子，回复可以看做写入操作，它是不频繁的，但是，浏览可以看做读取操作，是非常频繁的，这种情况就可以使用 ReadWriteLock。
        技术实现：ReadWriteLock
        缺点：如果有线程正在读，写线程需要等待读线程释放锁后才能获取写锁，即读的过程中不允许写，这是一种悲观的读锁。

    乐观锁
        概念：乐观锁就是乐观地估计读的过程中大概率不会有写入，因此被称为乐观锁。
               乐观锁的并发效率更高，但一旦有小概率的写入导致读取的数据不一致，需要能检测出来，再读一遍就行。
        技术实现：StampedLock提供了乐观读锁，可取代ReadWriteLock以进一步提升并发性能

    悲观锁
        概念：读的过程中拒绝有写入，也就是写入必须等待。

    Concurrent集合/java现成的并发包
        BlockingQueue概念：当一个线程调用这个TaskQueue的getTask()方法时，该方法内部可能会让线程变成等待状态，直到队列条件满足不为空，
                            线程被唤醒后，getTask()方法才会返回。 上面的例子里 ReentrantLock和Condition 实现了一个BlockingQueue
                          并发集合类，大大简化多线程编程，避免自己编写多线程同步代码！！！

        并发集合类 concurrent 清单：
            interface	non-thread-safe	                thread-safe
            List	    ArrayList	                    CopyOnWriteArrayList
            Map	        HashMap	                        ConcurrentHashMap
            Set	        HashSet / TreeSet	            CopyOnWriteArraySet
            Queue	    ArrayDeque / LinkedList	        ArrayBlockingQueue / LinkedBlockingQueue
            Deque	    ArrayDeque / LinkedList	        LinkedBlockingDeque

    Atomic
        概念：提供了一组原子操作的封装类

    线程池
        概念：线程池内部维护了若干个线程，没有任务的时候，这些线程都处于等待状态。如果有新任务，就分配一个空闲线程执行。
               如果所有线程都处于忙碌状态，新任务要么放入队列等待，要么增加一个新线程进行处理。

        实现类：
            FixedThreadPool：线程数固定的线程池
            CachedThreadPool：线程数根据任务动态调整的线程池
            SingleThreadExecutor：仅单线程执行的线程池。
            ScheduledThreadPool：有一种任务，需要定期反复执行，例如，每秒刷新证券价格。可以使用ScheduledThreadPool。
                                 同时我们完全可以用ScheduledThreadPool取代旧的Timer。

        例子：
            class Task15 implements Runnable {
                private final String name;

                public Task15(String name) {
                    this.name = name;
                }

                public void run() {
                    System.out.println("start task15 " + name);
                    try {
                        Thread.sleep(1000);
                    } catch (InterruptedException e) {

                    }
                    System.out.println("end task15 " + name);
                }
            }
            // ExecutorService接口表示线程池
            // 创建一个固定大小的线程池:
            ExecutorService es = Executors.newFixedThreadPool(4);
            for (int i = 0; i < 6; i++) {
                es.submit(new Task15(" " + i));
                // start task15  1
                // start task15  0
                // start task15  2
                // end task15  2
                // end task15  1
                // end task15  0
                // ...
            }
            // 关闭线程池
            es.shutdown();

    ForkJoin(特殊场景)
        概念：一种新的线程池，它可以执行一种特殊的任务：把一个大任务拆成多个小任务并行执行
             Fork/Join是一种基于“分治”的算法：通过分解任务，并行执行，最后合并结果得到最终结果。

        例子：
            class SumTask18 extends RecursiveTask<Long> {
                static final int THRESHOLD = 500;
                long[] array;
                int start;
                int end;

                SumTask18(long[] array, int start, int end) {
                    this.array = array;
                    this.start = start;
                    this.end = end;
                }

                @Override
                protected Long compute() {
                    if (end - start <= THRESHOLD) {
                        // 如果任务足够小,直接计算:
                        long sum = 0;
                        for (int i = start; i < end; i++) {
                            sum += this.array[i];
                            // 故意放慢计算速度:
                            try {
                                Thread.sleep(1);
                            } catch (InterruptedException e) {}
                        }
                        return sum;
                    }
                    // 任务太大，一分为二
                    int middle = (end + start) / 2;
                    System.out.println(String.format("split %d - %d ==> %d - %d, %d - %d", start, end, start, middle, middle, end));
                    // split 0 - 2000 ==> 0 - 1000, 1000 - 2000
                    // split 0 - 1000 ==> 0 - 500, 500 - 1000
                    // split 1000 - 2000 ==> 1000 - 1500, 1500 - 2000
                    SumTask18 subTask1 = new SumTask18(this.array, start, middle);
                    SumTask18 subTask2 = new SumTask18(this.array, middle, end);
                    // invokeAll会并行运行两个子任务:
                    invokeAll(subTask1, subTask2);
                    // 获得子任务的结果:
                    Long subResult1 = subTask1.join();
                    Long subResult2 = subTask2.join();
                    // 汇总结果:
                    Long result = subResult1 + subResult2;
                    System.out.println("result = " + subResult1 + " + " + subResult2 + " ===> " + result);
                    // result = 2485485 + 2491717 ===> 4977202
                    // result = 2391591 + 2419573 ===> 4811164
                    // result = 4811164 + 4977202 ===> 9788366
                    return result;
                }
            }
            // 创建2000个随机数组成的数组:
            long[] array18 = new long[2000];
            long expectedSum = 0;
            // 最笨的办法直接循环汇总结果
            for (int i = 0; i < array18.length; i++) {
                array18[i] = MyRandom();
                expectedSum += array18[i];
            }
            System.out.println("Expected sum:" + expectedSum);  // Expected sum:9788366
            // 引入 fork/join 线程池 汇总结果:
            ForkJoinTask<Long> task18 = new SumTask18(array18, 0, array18.length);
            // 获取当前系统毫秒数
            Long startTime = System.currentTimeMillis();
            Long result = ForkJoinPool.commonPool().invoke(task18);
            Long endTime = System.currentTimeMillis();
            System.out.println("Fork/join sum: " + result + " in " + (endTime - startTime) + " ms.");
            // Fork/join sum: 9788366 in 599 ms.

    CompletableFuture
        Future概念：ExecutorService.submit()方法，会返回一个Future类型，Future类型代表一个未来能获取结果的对象。
                   Future获得异步执行结果时，要么调用阻塞方法get()，要么轮询看isDone()是否为true，这两种方法会让主线程被迫等待。
        CompletableFuture概念：① 对Future做了改进，实现异步回调机制。可以传入回调对象，当异步任务完成或者发生异常时，自动调用回调对象的回调方法。
                              ② 多个CompletableFuture可以串行执行，可以并行执行。

        Callable接口: 比Runnable接口多了一个返回值，Callable接口是一个泛型接口，可以返回指定类型的结果

        例子：
            // 例子一，简单使用
            static Double fetchPrice16() {
                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {

                }
                if (Math.random() < 0.3) {
                    throw new RuntimeException("fetch price16 failed");
                }
                return 5 + Math.random() * 100;
            }
            // 创建异步执行任务:
            CompletableFuture<Double> cf16 = CompletableFuture.supplyAsync(ZzzzApplication::fetchPrice16);
            // 如果执行成功:
            cf16.thenAccept((result) -> {
                System.out.println("price16: " + result);   // price16: 17.597618167576652
            });
            // 如果执行异常:
            cf16.exceptionally((e) -> {
                e.printStackTrace();
                return null;
            });
            // 主线程不要立刻结束，否则CompletableFuture默认使用的线程池会立刻关闭:
            try {
                Thread.sleep(500);
            } catch (InterruptedException e) {}

            // 例子二，多个CompletableFuture并行执行
            static String queryCode17(String name, String address) {
                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {}
                return "601857";
            }

            static Double fetchPrice17(String code, String addr) {
                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {}
                return 5 + Math.random() * 10;
            }
            // 两个CompletableFuture执行异步查询:
            CompletableFuture<String> cfQueryFromSina = CompletableFuture.supplyAsync(() -> {
                return queryCode17("中国石油", "https://finance.sina.com.cn/code/");
            });
            CompletableFuture<String> cfQueryFrom163 = CompletableFuture.supplyAsync(() -> {
                return queryCode17("中国石油", "https://money.163.com/code/");
            });
            // 用anyOf合并为一个新的CompletableFuture:
            CompletableFuture<Object> cfQuery17_2 = CompletableFuture.anyOf(cfQueryFromSina, cfQueryFrom163);
            // 两个CompletableFuture执行异步查询:
            CompletableFuture<Double> cfFetchFromSina = cfQuery17_2.thenApplyAsync((code) -> {
                return fetchPrice17((String) code, "https://finance.sina.com.cn/price/");
            });
            CompletableFuture<Double> cfFetchFrom163 = cfQueryFrom163.thenApplyAsync((code) -> {
                return fetchPrice17((String) code, "https://money.163.com/price/");
            });
            // 用anyOf合并为一个新的CompletableFuture:
            CompletableFuture<Object> cfFetch17_2 = CompletableFuture.anyOf(cfFetchFromSina, cfFetchFrom163);
            // 最终结果:
            cfFetch17_2.thenAccept((result) -> {
                System.out.println("price17_2: " + result);  // price17_2: 13.023957920342694
            });
            // 主线程不要立刻结束，否则CompletableFuture默认使用的线程池会立刻关闭:
            try {
                Thread.sleep(500);
            } catch (InterruptedException e) {}

    ThreadLocal
        概念：如何在一个线程内传递状态？ ThreadLocal，它可以在一个线程中传递同一个对象
             ThreadLocal相当于给每个线程都开辟了一个独立的存储空间，各个线程的ThreadLocal关联的实例互不干扰
        注意：ThreadLocal一定要在finally中清除。因为当前线程执行完后，会被重新放入线程池中，如果没被清除，下次再执行次线程时，会把上一次的状态带进去。

        上下文（Context）：在一个线程中，横跨若干方法调用，需要传递的对象，我们通常称之为上下文（Context），它是一种状态，可以是用户身份、任务信息等

        例子：
            // 例子一，Thread.currentThread().getName()
            static void LogHere(String s) {
                System.out.println(Thread.currentThread().getName() + " 线程: " + s);
            }
            // 获取当前线程的信息
            LogHere("start logHere...");
            new Thread(() -> {
                LogHere("run task19 ...");
            }).start();
            new Thread(() -> {
                LogHere("print task19 ...");
            }).start();
            LogHere("end logHere...");
            // main 线程: start logHere...
            // Thread-29 线程: run task19 ...
            // main 线程: end logHere...
            // Thread-30 线程: print task19 ...

            // 例子二，ThreadLocal
            class Task20 implements Runnable {
                final String username;

                public Task20(String username) {
                    this.username = username;
                }

                @Override
                public void run() {
                    try (var ctx = new UserContext(this.username)) {
                        new Task1().process();
                        new Task2().process();
                        new Task3().process();
                    }
                }
            }
            class UserContext implements AutoCloseable {
                private static final ThreadLocal<String> userThreadLocal = new ThreadLocal<>();

                public UserContext(String name) {
                    userThreadLocal.set(name);
                    System.out.printf("[%s]① init user %s...\n", Thread.currentThread().getName(), UserContext.getCurrentUser());
                }

                public static String getCurrentUser() {
                    return userThreadLocal.get();
                }

                @Override
                public void close() {
                    System.out.printf("[%s]⑤ cleanup for user %s...\n", Thread.currentThread().getName(), UserContext.getCurrentUser());
                    userThreadLocal.remove();
                }
            }
            class Task1 {
                public void process() {
                    try {
                        Thread.sleep(100);
                    } catch (InterruptedException e) { }
                    System.out.printf("[%s]② check user %s...\n", Thread.currentThread().getName(), UserContext.getCurrentUser());
                }
            }
            class Task2 {
                public void process() {
                    try {
                        Thread.sleep(100);
                    } catch (InterruptedException e) { }
                    System.out.printf("[%s]③ %s registered ok...\n", Thread.currentThread().getName(), UserContext.getCurrentUser());
                }
            }
            class Task3 {
                public void process() {
                    try {
                        Thread.sleep(100);
                    } catch (InterruptedException e) { }
                    System.out.printf("[%s]④ %s\'s work has done...\n", Thread.currentThread().getName(), UserContext.getCurrentUser());
                }
            }
            ExecutorService es20 = Executors.newFixedThreadPool(3);
            String[] users20 = new String[] {"Bob", "Alice", "Tim", "Mike", "Lily", "Jack", "Bush"};
            for (String user : users20) {
                es20.submit(new Task20(user));
                // [pool-2-thread-1]① init user Bob...
                // [pool-2-thread-2]① init user Alice...
                // [pool-2-thread-2]② check user Alice...
                // [pool-2-thread-1]② check user Bob...
                // [pool-2-thread-2]③ Alice registered ok...
                // [pool-2-thread-1]③ Bob registered ok...
                // [pool-2-thread-3]① init user Mike...
                // [pool-2-thread-2]④ Alice's work has done...
                // [pool-2-thread-1]④ Bob's work has done...
                // [pool-2-thread-1]⑤ cleanup for user Bob...
                // [pool-2-thread-2]⑤ cleanup for user Alice...
                // [pool-2-thread-1]① init user Lily...
            }
            try {
                es20.awaitTermination(3, TimeUnit.SECONDS);
                es20.shutdown();
            } catch (InterruptedException e) {}


11、








