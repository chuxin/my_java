1、Java数据类型 & 流程控制
    Java的数据类型分两种：
        基本类型：byte，short，int，long，boolean，float，double，char
            整数类型：byte，short，int，long
            浮点数类型：float，double
            字符类型：char
            布尔类型：boolean
        引用类型：所有class和interface类型
            注意：引用类型可以赋值为null，表示空，但基本类型不能赋值为null

    Java基本数据类型占用的字节数：
        byte - 1, short - 2, int - 4, long - 8, float - 4, double - 8, char - 2

    基本数据类型
        整型：byte，short，int，long
        例子：
            int x = 1;
            System.out.println("x 第一次的值：" + x);     // x 第一次的值：1
            long l = 33L;
            System.out.println("l 的值：" + l);          // l 的值：33

        浮点型：float，double，NaN(表示Not a Number)，Infinity(表示无穷大)，-Infinity(表示负无穷大)
        例子：
            float f1 = 3.1415f;
            float f2 = 3.2e5f;
            System.out.println("f1的值：" + f1 + " f2的值：" + f2);   // f1的值：3.1415  f2的值：320000.0
            double d1 = 4.1e5;
            System.out.println("d1 的值：" + d1);  // d1 的值：410000.0
            // 浮点数运算会产生误差
            double d3 = 1.0 / 10;
            double d4 = 1 - 9.0 / 10;
            System.out.println("d3的值：" + d3);       // d3的值：0.1
            System.out.println("d4的值：" + d4);       // d4的值：0.09999999999999998
            // 浮点数不精确问题
            double x2 = 1 - 9.0 / 10;
            System.out.println("x2的值：" + x2);   // x2的值：0.09999999999999998
            if (x2 == 0.1) {        // 计算出现误差
                System.out.println("x2 == 0.1 为 true");
            } else {
                System.out.println("x2 == 0.1 为 false");    // x2 == 0.1 为 false
            }
            if (Math.abs(x2 - 0.1) < 0.00001) {
                System.out.println("Math.abs(x2 - 0.1) < 0.00001 为 true");  // Math.abs(x2 - 0.1) < 0.00001 为 true
            } else {
                System.out.println("Math.abs(x2 - 0.1) < 0.00001 为 false");
            }
            // 特殊值
            double d1 = 0.0 / 0;        // NaN
            double d2 = 1.0 / 0;        // Infinity
            double d3 = -1.0 / 0;       // -Infinity

        布尔类型：boolean
        例子：
            boolean b1 = true;
            boolean isGreater = 5 > 4;
            System.out.println("b1的值：" + b1);       // b1的值：true
            System.out.println("isGreater的值：" + isGreater); // isGreater的值：true

        字符类型：char
        例子：
            // 注意char类型使用单引号'，且仅有一个字符，要和双引号"的字符串类型区分开。
            char a = 'A';
            char zh = '中';
            System.out.println("字符a的值：" + a);   // 字符a的值：A
            System.out.println("字符zh的值：" + zh); // 字符zh的值：中

    引用类型
        概念：除了基本类型，剩下的都是引用类型。最常用的就是String字符串
        例子：
            // 字符串
            String s = "hello";
            String s2 = "中国";
            System.out.println("s的值：" + s);     // s的值：hello
            System.out.println("s2的值：" + s2);   // s2的值：中国
            // 空字符串是一个有效的字符串对象，它不等于null
            String s7 = null;
            System.out.println("s7的值：" + s7);   // s7的值：null
            // 字符串比较，不能用 == ，改用 equals
            // 引用类型使用Objects.equals()比较，基本类型使用==比较
            String ss1 = "hello";
            String ss2 = "Hello".toLowerCase();
            if (ss1 == ss2) {
                System.out.println("ss1 == ss2 为 true");
            } else {
                System.out.println("ss1 == ss2 为 false");       // ss1 == ss2 为 false
            }
            if (ss1.equals(ss2)) {
                System.out.println("ss1.equals(ss2) 为 true");   // ss1.equals(ss2) 为 true
            } else {
                System.out.println("ss1.equals(ss2) 为 false");
            }
            // 常量
            final double PI = 3.3;
            System.out.println("PI的值：" + PI);   // PI的值：3.3
            // var关键字。编译器会根据赋值语句自动推断出变量v1的类型
            var v1 = "你好xxx";
            System.out.println(v1);               // 你好xxx

            // 数组定义
            // 定义方式①
            int[] ns = new int[5];
            ns[0] = 11; ns[1] = 12; ns[2] = 13; ns[3] = 14; ns[4] = 15;
            System.out.println("ns的第二个值：" + ns[1]);     // ns的第二个值：12
            System.out.println("ns的长度：" + ns.length);    // ns的长度：5
            // 定义方式②
            int[] ns2 = new int[] {1, 2, 3, 4, 5};
            System.out.println("ns2的长度：" + ns2.length);  // ns2的长度：5
            // 定义方式③
            int[] ns3 = {1, 3, 5, 7, 9};
            System.out.println("ns3的长度：" + ns3.length);  // ns3的长度：5
            // 数组排序
            int[] ttArr = {8, 4, 1, 5, 7, 6};
            Arrays.sort(ttArr);
            System.out.println("ttArr数组排序后的内容：" + Arrays.toString(ttArr));  // ttArr数组排序后的内容：[1, 4, 5, 6, 7, 8]
            System.out.println(Arrays.toString(ttArr).equals("[1, 4, 5, 6, 7, 8]"));    // true
            String[] arr = new String[]{"Apple", "Orange", "Banana", "Lemon"};
            Arrays.sort(arr, (s1, s2) -> {
                return s1.compareTo(s2);
            });
            Arrays.sort(arr);
            System.out.println(Arrays.toString(arr));   // [Apple, Banana, Lemon, Orange]
            // 数组浅拷贝
            // Arrays.copyOf  把一个数组的区间值完全赋给另一个数组， 区间的开始和结束位置遵循 左闭右开原则
            int a[] = {4, 3, 6, 5, 1, 2};
            int b[] = Arrays.copyOf(a, 4);
            int c[] = Arrays.copyOfRange(a, 2, 5);
            System.out.println(Arrays.toString(b));     // [4, 3, 6, 5]
            System.out.println(Arrays.toString(c));     // [6, 5, 1]
            // 二维数组
            int[][] twoDimenArr = {
                    {15, 6, 7, 8},
                    {9, 20, 11, 12, 88},
                    {1, 3, 7, 0}
            };
            System.out.println("二维数组 twoDimenArr 的长度：" + twoDimenArr.length);   // 二维数组 twoDimenArr 的长度：3
            System.out.println("二维数组 twoDimenArr, 第二维的值：" + Arrays.toString(twoDimenArr[1])); // 二维数组 twoDimenArr, 第二维的值：[9, 20, 11, 12, 88]
            System.out.println("二维数组 twoDimenArr, 第二维的长度：" + twoDimenArr[1].length); // 二维数组 twoDimenArr, 第二维的长度：5
            System.out.println("二维数组 twoDimenArr, 打印某个值：" + twoDimenArr[1][1]); // 二维数组 twoDimenArr, 打印某个值：20
            // 打印二维数组
            for (int[] onePiece : twoDimenArr) {
                System.out.print("二维中的每一维值：");
                for (int oneEle : onePiece) {
                    // 二维中的每一维值：15, 6, 7, 8,
                    // 二维中的每一维值：9, 20, 11, 12, 88,
                    // 二维中的每一维值：1, 3, 7, 0,
                    System.out.print(oneEle + ", ");
                }
                System.out.println();
            }
            // 一次性打印二维数组：[[15, 6, 7, 8], [9, 20, 11, 12, 88], [1, 3, 7, 0]]
            System.out.println("一次性打印二维数组：" + Arrays.deepToString(twoDimenArr));
            // 定义三维数组
            int[][][] threeDimenArr = {
                    {
                            {1, 3, 7},
                            {4, 2, 9}
                    },
                    {
                            {11, 31, 7},
                            {41, 21, 9},
                            {42, 22, 91}
                    },
                    {
                            {21, 311, 7},
                            {31, 111, 9},
                            {12, 212, 91}
                    }
            };
            // 一次性打印三维数组：[[[1, 3, 7], [4, 2, 9]], [[11, 31, 7], [41, 21, 9], [42, 22, 91]], [[21, 311, 7], [31, 111, 9], [12, 212, 91]]]
            System.out.println("一次性打印三维数组：" + Arrays.deepToString(threeDimenArr));

    变量作用域
        概念：以{ }作为它们自身的作用范围
        例子：
            if (true) {
                int x1 = 11;
                if (true) {
                    int x2 = 22;
                    System.out.println(x2);      // 22
                }
                // System.out.println(x2);       // 作用域报错
            }

    类型自动提升与强制转型
        概念：如果参与运算的两个数类型不一致，那么计算结果为较大类型的整型
        注意：整型和浮点型运算时，整型会自动提升为浮点型
        例子：
            short s3 = 1234;
            int ii = 123456;
            int x5 = s3 + ii;
            System.out.println("x5 的值：" + x5);      // x5 的值：124690
            short y2 = (short) (s3 + ii);  // 超出范围的强制转型会得到错误的结果，原因是转型时，int的两个高位字节直接被扔掉，仅保留了低位的两个字节
            System.out.println("y 的值：" + y2);       // y 的值：-6382
            // 把 int 转成 String
            int i1 = 3, i2 = 4, i3 = 5;
            String s8  = String.valueOf(i1 + i2 + i3);
            System.out.println(s8);     // 12

    流程控制
        例子：
            // for 循环 ①
            int[] nsArr = {1, 3 ,5 ,7, 0};
            sum = 0;
            for (int i = 0; i < nsArr.length; i++) {
                sum += nsArr[i];
            }
            System.out.println("sum的值：" + sum); // sum的值：16
            // for 循环 ②
            for(int j : nsArr) {
                System.out.println("遍历数组的值：" + j);  // 遍历数组的值：1 3 5 7 0
            }
            // break 使用
            for (int i=1; i<4; i++) {
                System.out.println("i的值：" + i); // i的值：1 2 3
                for (int j=1; ;j++) {
                    if (j == 10) {
                        System.out.println("j的值:" + j); // j的值:10
                        break;
                    }
                }
            }


2、面向对象
    构造方法
        public class OOPknowledge {
            public String val11;
            public int age11;
            public String val22;

            public String name = "parentName";
            public int age;
            protected String nationality = "China";
            public String address;
            private int sex;

            public String[] formerNames;
            public String[] formerAddresses;

            public String country;
            public String secondCountry;

            public final int quota;

            // 第一个构造函数
            public OOPknowledge() {
                // 什么都没有
            }
            // 第二个构造函数
            public OOPknowledge(String val11, int age11) {
                this.val11 = val11;
                this.age11 = age11;
            }
            // 第三个构造函数
            public OOPknowledge(String val22) {
                // 这里第三个构造函数 去 调用第二个构造方法
                this("ccc22", 44);
                this.val22 = val22;
            }
            public String getAddress() {
                // 判断非 null，非空
                if (this.address == null || this.address.isBlank()) {
                    throw new IllegalArgumentException("invalid name");
                }
                // 去掉首尾空格
                return this.address.strip();
            }
            public void setSex(int sex) {
                if (this.sex > 100) {
                    throw new IllegalArgumentException("invalid sex value");
                }
                this.sex = sex;
            }
            public int getSex() {
                return sex;  // 如果没有命名冲突，可以省略this
            }
            // 可变参数
            public void getFormerNames(String... formerNames) {
                this.formerNames = formerNames;
                System.out.println("曾用名：" + Arrays.toString(this.formerNames));
            }
            public void getFormerAddresses(String[] formerAddresses) {
                this.formerAddresses = formerAddresses;
                System.out.println("曾用地址：" + Arrays.toString(this.formerAddresses));
            }
            public void setCountry(String country) {
                this.country = country;
            }
            public void setCountry(String country, String secondCountry) {
                this.country = country;
                this.secondCountry = secondCountry;
            }
            public TestFinal(int quota) {
                this.quota = quota;
            }
            public void getThirdChildValue() {
                System.out.println("我是父类 OOPknowledge ");
            }
        }
        public class FirstChild extends OOPknowledge {
            private String name = "childName";

            public void getSelfAttributes() {
                System.out.println("获取当前类的属性name(注意，此name属性父类也有)：" + this.name);
                System.out.println("获取父类的属性name：" + super.name);
            }
        }
        public class ThirdChild extends OOPknowledge {
            @Override
            public void getThirdChildValue() {
                System.out.println("我是子类 ThirdChild ");
            }
            // overload
            public int getThirdChildValue22(int test) {
                System.out.println("我是子类方法 getThirdChildValue22 - " + test);
                return 22;
            }
        }
        // 构造方法没有返回值（也没有void），调用构造方法，必须用new操作符
        // 没有定义构造方法时，编译器会自动创建一个默认的无参数构造方法
        OOPknowledge mtObj = new OOPknowledge();
        System.out.println("第一个构造函数传入的值：" + mtObj.val11 + " " + mtObj.age11);     // 第一个构造函数传入的值：null 0
        OOPknowledge mtObj11 = new OOPknowledge("bbb", 33);
        System.out.println("第二个构造函数传入的值：" + mtObj11.val11 + " " + mtObj11.age11); // 第二个构造函数传入的值：bbb 33
        OOPknowledge mtObj22 = new OOPknowledge("ccc");
        System.out.println("第三个构造函数传入的值：" + mtObj22.val22 + mtObj22.val11 + mtObj22.age11); // 第三个构造函数传入的值：ccc ccc22 44
        // 可变参数用类型...定义，可变参数相当于数组类型
        OOPknowledge mtObj = new OOPknowledge();
        mtObj.getFormerNames("aa", "bb", "xxx", "yyy");       // 曾用名：[aa, bb, xxx, yyy]
        mtObj.getFormerNames("aa");     // 曾用名：[aa]
        mtObj.getFormerNames();         // 曾用名：[]
        mtObj.getFormerNames(null);     // 曾用名：null
        mtObj.getFormerAddresses(new String[] {"mm", "nn", "pp"});  // 曾用地址：[mm, nn, pp]
        mtObj.getFormerAddresses(new String[] {});  // 曾用地址：[]
        mtObj.getFormerAddresses(null);     // 曾用地址：null

    向上转型 & 向下转型
        // 向上转型
        FirstChild fcObj22 = new FirstChild();
        OOPknowledge oopObj22 = fcObj22;
        Object o1 = fcObj22;
        Object o2 = oopObj22;
        Object o3 = null;
        // 向下转型会报错
        OOPknowledge oopObj33 = new OOPknowledge();
        // FirstChild fcObj33 = (FirstChild) oopObj33;       // cannot be cast to
        // instanceof实际上判断一个变量所指向的实例是否是指定类型，或者这个类型的子类
        // 避免转型出错，先判断一个实例究竟是不是某种类型
        if (o3 instanceof OOPknowledge) {
            System.out.println("父类对象 o3 属于 子类 OOPknowledge 的实例");
        }
        if (fcObj22 instanceof OOPknowledge) {
            System.out.println("子类对象 fcObj22 属于 父类 OOPknowledge 的实例"); // 子类对象 fcObj22 属于 父类 OOPknowledge 的实例
        }

    多态
        // override 方法名相同，参数相同，返回值类型相同
        // overload 方法名相同，返回值类型相同, 但参数不同。
        // Java的实例方法调用是基于运行时的实际类型的动态调用，而非变量的声明类型。这个非常重要的特性在面向对象中称之为多态
        OOPknowledge tcObj = new ThirdChild();
        tcObj.getThirdChildValue();     // 我是子类 ThirdChild
        OOPknowledge oopObj44 = new OOPknowledge();
        oopObj44.getThirdChildValue();  // 我是父类 OOPknowledge

    抽象类
        public abstract class Person {
            public abstract void run();
        }
        public class Student extends Person {
            @Override
            public void run() {
                System.out.println("student.run");
            }
        }
        com.example.demo.testAbstract.Student studentObj = new com.example.demo.testAbstract.Student();
        studentObj.run();   // student.run

    接口
        // 如果一个抽象类没有字段，所有方法全部都是抽象方法，就可以把该抽象类改写为接口
        // 所谓interface，就是比抽象类还要抽象的纯抽象接口，因为它连字段都不能有。因为接口定义的所有方法默认都是public abstract的，所以这两个修饰符不需要写出来（写不写效果都一样）。
        //
        //              abstract class	        interface
        // 继承	        只能extends一个class	    可以implements多个interface
        // 字段	        可以定义实例字段	        不能定义实例字段
        // 抽象方法	    可以定义抽象方法	        可以定义抽象方法
        // 非抽象方法	    可以定义非抽象方法	        可以定义default方法
        //
        // 合理设计interface和abstract class的继承关系，可以充分复用代码。一般来说，公共逻辑适合放在abstract class中，
        // 具体逻辑放到各个子类，而接口层次代表抽象程度。
        public interface Hello {
            void hello();
        }
        public interface Person {
            void run();
            String getName();

            default void noNeedInherit() {
                System.out.println(getName() + " noNeedInherit");
            }
            default void noNeedInherit2() {
                System.out.println("我是父类的noNeedInherit2");
            }
        }
        public class Student implements Person, Hello {
            public String name;

            public Student(String name) {
                this.name = name;
            }
            @Override
            public void run() {
                System.out.println(this.name + " run");
            }
            @Override
            public String getName() {
                return this.name;
            }
            @Override
            public void hello() {
                System.out.println(this.name + " hello");
            }
            @Override
            public void noNeedInherit() {
                System.out.println("我是子类的noNeedInherit");
            }
        }
        com.example.demo.testInterface.Student myStuObj = new com.example.demo.testInterface.Student("我的学生");
        myStuObj.run();     // 我的学生 run
        System.out.println("MyStudent->name: " + myStuObj.getName());   // MyStudent->name: 我的学生
        // 接口定义 default 方法（JDK>=1.8），那么子类就不再必须重写此方法，只需要在需要覆写的地方去覆写。
        // default方法和抽象类的普通方法是有所不同的。因为interface没有字段，default方法无法访问字段，而抽象类的普通方法可以访问实例字段。
        myStuObj.noNeedInherit();   // 我是子类的noNeedInherit
        myStuObj.noNeedInherit2();  // 我是父类的noNeedInherit2

    静态字段 & 静态方法
        // 静态字段
        // 实例字段：在一个class中定义的字段，实例字段在每个实例中都有自己的一个独立“空间”
        // 静态字段：只有一个共享“空间”，所有实例都会共享该字段。
        public class MyStatic {
            public static int number;
            public static int age;

            public static void setAge(int param) {
                age = param;
            }
        }
        public interface StaticInterface {
            public static final int male = 1;
            int female = 2;         // 编译器会自动加上public statc final:
        }
        MyStatic msObj11 = new MyStatic();
        msObj11.number = 88;
        System.out.println("静态字段值共享：" + MyStatic.number);
        // 静态方法
        // 调用静态方法通过类名就可以调用
        // 静态方法内部，无法访问this变量，也无法访问实例字段，它只能访问静态字段。
        // 静态方法经常用于工具类。例如：Arrays.sort()     Math.random()
        MyStatic.setAge(77);
        System.out.println("静态方法里对静态字段 age 赋值了： " + MyStatic.age);  // 静态方法里对静态字段 age 赋值了： 77
        System.out.println("接口静态字段： " + StaticInterface.male + ", " + StaticInterface.female); // 接口静态字段： 1, 2

    作用域 & 三种内部类
        // import.* 表示把这个包下面的所有class都导入进来（但不包括子包的class）
        // 默认自动import当前package的其他class
        // 默认自动import java.lang.*
        // 确定唯一的包名。推荐的做法是使用倒置的域名来确保唯一性。例如：  com.liaoxuefeng.sample
        //
        // 包作用域是指一个类允许访问同一个package的没有public、private修饰的class，以及没有public、protected、private修饰的字段和方法。
        // 同一个package指：包名必须完全一致，包没有父子关系，com.apache和com.apache.abc是不同的包。
        //
        // 最佳实践
        // 如果不确定是否需要public，就不声明为public，即尽可能少地暴露对外的字段和方法。
        // 一个.java文件只能包含一个public类，但可以包含多个非public类。如果有public类，文件名必须和public类的名字相同。
        // Java内建的访问权限包括public、protected、private和package权限
        // 阅读代码的时候，应该先关注public方法
        public class MyScope {
            public void doSomething() {
                MyInner miObj = new MyInner();
                miObj.printSome();
            }
            public void doSomething2() {
                Outer2 outerObj = new Outer2(1);
                Outer2.YouInner yiObj = outerObj.new YouInner();
                yiObj.printYouSome();
            }
            public void doSomething3() {
                Outer3 outerObj = new Outer3("用异步编程测试匿名类");
                outerObj.asyncHello();
            }
            public void doSomething4() {
                Outer4.YouInner yiObj = new Outer4.YouInner();
                yiObj.hello();
            }
            private static void printFather() {
                System.out.println("类名为：MyScope");
            }
            static class MyInner {
                public void printSome() {
                    MyScope.printFather();
                }
            }
        }
        class Outer2 {
            private int sex = 0;
            public Outer2(int sex) {
                this.sex = sex;
            }
            class YouInner {
                public void printYouSome() {
                    System.out.println("printYouSome: " + Outer2.this.sex);
                }
            }
        }
        class Outer3 {
            private String name;

            Outer3(String name) {
                this.name = name;
            }
            void asyncHello() {
                // 匿名类!
                Runnable r = new Runnable() {
                    @Override
                    public void run() {
                        System.out.println("hello, " + Outer3.this.name);
                    }
                };
                new Thread(r).start();
            }
        }
        class Outer4 {
            private static String yourName = "Louis";
            private String name;

            Outer4(String name) {
                this.name = name;
            }
            static class YouInner {
                void hello() {
                    System.out.println("测试内部静态类" + Outer4.yourName);
                }
            }
        }
        // Java支持嵌套类，如果一个类内部还定义了嵌套类，那么，嵌套类拥有访问private的权限
        MyScope msObj = new MyScope();
        msObj.doSomething();    // 类名为：MyScope
        // 三种内部类
        // ① 内部类(Inner Class)
        msObj.doSomething2();   // printYouSome: 1
        // ② 匿名类(Anonymous Class)
        msObj.doSomething3();   // hello, 用异步编程测试匿名类
        // ③ 静态嵌套类(Static Nested Class)
        msObj.doSomething4();   // 测试内部静态类Louis

    classpath(没实践)
        // classpath是JVM用到的一个环境变量，它用来指示JVM如何搜索class
        // 在系统环境变量中设置classpath环境变量，不推荐
        // 在启动JVM时设置classpath变量，推荐

    jar(没实践)
        // 对散落在各层目录中的.class文件打成一个包
        // Maven，可以非常方便地创建jar包
        // JVM自带的Java标准库，实际上也是以jar文件形式存放的，这个文件叫rt.jar，一共有60多M
        // 学习地址：https://www.liaoxuefeng.com/wiki/1252599548343744/1260466914339296

    模块(没实践)
        // 如果a.jar必须依赖另一个b.jar才能运行，那我们应该给a.jar加点说明啥的，让程序在编译和运行的时候能自动定位到b.jar，这种自带“依赖关系”的class容器就是模块
        // 模块的重要作用就是声明依赖关系
        // 学习地址：https://www.liaoxuefeng.com/wiki/1252599548343744/1281795926523938


3、核心类
    字符串相关
        // 大写字符串
        String s = "hello".toUpperCase();
        System.out.println(s);  // HELLO

        // 比较字符串
        String s1 = "hello11";
        String s2 = "hello11";
        System.out.println("字符串比较：" + (s1 == s2));      // 字符串比较：true
        System.out.println("字符串比较：" + s1.equals(s2));   // 字符串比较：true
        String s3 = "hello22";
        String s4 = "HELLo22".toLowerCase();
        System.out.println("字符串比较：" + (s3 == s4));      // 字符串比较：false
        System.out.println("字符串比较：" + s3.equals(s4));   // 字符串比较：true
        System.out.println("字符串比较(忽略大小写)：" + s3.equalsIgnoreCase(s4));  // 字符串比较(忽略大小写)：true

        // 字符串查找
        System.out.println("hello".contains("ll"));         // true
        System.out.println("hello".startsWith("he"));       // true
        System.out.println("hello".endsWith("lo"));         // true
        System.out.println("hello".indexOf("l"));           // 2
        String s = "Test string";
        int n1 = s.indexOf("t");
        int n2 = s.indexOf("es");
        int n3 = s.indexOf("t", 4);
        System.out.println("indexOf函数，传入不同参数，返回的位置分别是：" + n1 + ", " + n2 + ", " + n3); // indexOf函数，传入不同参数，返回的位置分别是：3, 1, 6

        // 截取字符串
        System.out.println("hello".substring(2));           // llo
        System.out.println("hello".substring(2, 3));        // l

        // 去除首尾空白字符
        System.out.println(" \thello\r\n".trim());          // hello
        // 中文的空格字符\u3000
        System.out.println("\u3000hello\u3000".strip());    // hello
        System.out.println(" hello ".stripLeading());       // hello
        System.out.println(" hello ".stripTrailing());      //  hello

        // isEmpty()和isBlank()来判断字符串是否为空和空白字符串
        System.out.println("".isEmpty());                   // true
        System.out.println(" ".isEmpty());                  // false
        System.out.println(" \n".isBlank());                // true
        System.out.println(" hello ".isBlank());            // false

        // 替换字符串
        System.out.println("hello".replace("l", "w"));      // hewwo
        System.out.println("hello".replace("ll", "~~"));    // he~~o
        System.out.println("A,,B;C ,D".replaceAll("[\\,\\;\\s]+", ","));    // A,B,C,D

        // 分割字符串
        String s5 = "A,B,C,D";
        String[] s5Arr = s5.split("\\,");
        // String[] s5Arr = s5.split(",");  // 一样的结果
        System.out.println(Arrays.toString(s5Arr));      // [A, B, C, D]

        // 拼接字符串
        // ① StringBuilder  高效拼接字符串, 不会每次循环都会创建新的字符串对象
        String[] namesArr = {"bob", "alice", "grace"};
        var sb2 = new StringBuilder();
        sb2.append("hello ");
        for (String name:namesArr) {
            sb2.append(name).append(", ");
        }
        sb2.delete(sb2.length()-2, sb2.length());
        sb2.append("!");
        System.out.println(sb2.toString());     // hello bob, alice, grace!
        // ② StringJoiner  拼接
        var sj = new StringJoiner(", ", "hello ", "!");
        for (String name:namesArr) {
            sj.add(name);
        }
        System.out.println(sj.toString());      // hello bob, alice, grace!
        // ③ String.join
        String[] s6Arr = {"x", "y", "z"};
        String s6 = String.join("--", s6Arr);
        System.out.println(s6);         // x--y--z

        // 格式化输出
        // 如果你不确定用啥占位符，那就始终用%s，因为%s可以显示任何数据类型
        String s7 = "Hi %s, your score is %.2f, your age is %d";
        System.out.println(String.format(s7, "louis", 88.8, 99));   // Hi louis, your score is 88.80, your age is 99
        double d2 = 3.131456;
        System.out.printf("%.2f\n", d2);    // 3.13

    类型转换
        // 把任意基本类型或引用类型转换为字符串
        System.out.println(String.valueOf(123));           // 123
        System.out.println(String.valueOf(45.67));         // 45.67
        System.out.println(String.valueOf(true));          // true
        System.out.println(String.valueOf(new Object()));  // java.lang.Object@776ec8df

        // 把字符串转换为int类型
        System.out.println(Integer.parseInt("123"));    // 123
        // int和Integer互相转换
        // int 是基本数据类型，直接存数值，而integer是对象，是int的封装类，用一个引用指向这个对象
        // int和Integer都可以表示某一个数值；
        Integer n = null;
        Integer n2 = Integer.valueOf(99);
        int n3 = n2.intValue();
        System.out.println(n3);             // 99
        Integer n4 = Integer.valueOf("88");
        System.out.println(n4.intValue());  // 88
        // 编译器把Integer x = 127;自动变为Integer x = Integer.valueOf(127);
        // 为了节省内存，Integer.valueOf()对于较小的数，始终返回相同的实例，因此，==比较“恰好”为true，
        // 但我们绝不能因为Java标准库的Integer内部有缓存优化就用==比较，必须用equals()方法比较两个Integer
        // Integer有个getInteger(String)方法，它不是将字符串转换为int，而是把该字符串对应的系统变量转换为Integer
        System.out.println(Integer.getInteger("java.version")); // null

        // 把字符串解析成一个整数
        int n9 = Integer.parseInt("100");

        // 字符串转换为boolean类型
        System.out.println(Boolean.parseBoolean("true"));   // true
        System.out.println(Boolean.parseBoolean("FALSE"));  // false

        // 字符和字符串互转
        // String -> char[]
        char[] cs = "hello".toCharArray();
        System.out.println(Arrays.toString(cs));            // [h, e, l, l, o]
        // char[] -> String
        String s8 = new String(cs);
        System.out.println(s8);                             // hello

        // 所有的整数和浮点数的包装类型都继承自Number, 包装类型 转换为 各种基本类型
        Number num = Integer.valueOf(77);
        byte b = num.byteValue();
        int n10 = num.intValue();
        long l = num.longValue();
        double d = num.doubleValue();
        float f2 = num.floatValue();
        System.out.println(b + " " + n10 + " " + l + " " + d + " " + f2);  // 77 77 77 77.0 77.0

    一些有用的静态变量
        Boolean t = Boolean.TRUE;
        Boolean f = Boolean.FALSE;
        int max = Integer.MAX_VALUE;
        int min = Integer.MIN_VALUE;
        int sizeOfLong = Long.SIZE;
        int byteOfLong = Long.BYTES;
        // true  false  2147483647  -2147483648  64  8
        System.out.println(t + " " + f + " " + max + " " + min + " " + sizeOfLong + " " + byteOfLong);

    javabean
        // 把一组对应的读方法（getter）和写方法（setter）称为属性（property）
        // boolean字段比较特殊，它的读方法一般命名为isXyz()
        // 只有getter的属性，没有setter属性的，称为只读属性（read-only），反之为只写属性（write-only）
        // 枚举JavaBean属性
        public class MyJavaBean {
            private String name;

            public String getName() {
                return name;
            }
            public void setName(String name) {
                this.name = name;
            }
        }
        try {
            BeanInfo info = Introspector.getBeanInfo(MyJavaBean.class);
            for (PropertyDescriptor piece:info.getPropertyDescriptors()) {
                // getName(): class
                // getReadMethod(): public final native java.lang.Class java.lang.Object.getClass()
                // getWriteMethod(): null
                // getName(): name
                // getReadMethod(): public java.lang.String com.example.demo.coreClass.MyJavaBean.getName()
                // getWriteMethod(): public void com.example.demo.coreClass.MyJavaBean.setName(java.lang.String)
                System.out.println("getName(): " + piece.getName());
                System.out.println("getReadMethod(): " + piece.getReadMethod());
                System.out.println("getWriteMethod(): " + piece.getWriteMethod());
            }
        } catch (IntrospectionException e) {
            System.out.println(e.getMessage());
        }

    枚举类型 enum
        // 使用enum定义的枚举类是一种引用类型
        // enum类型可以使用==比较，也可以使用equals()方法比较，是个例外
        // enum的构造方法要声明为private，字段强烈建议声明为final
        public enum Weekday {
            SUN(0, "星期天"), MON(1, "星期一"), TUE(2, "星期二"), WES(3, "星期三"),
            THU(4, "星期四"), FRI(5, "星期五"), SAT(6, "星期六");

            public final int dayValue;
            private final String name;

            private Weekday(int dayValue, String name) {
                this.dayValue = dayValue;
                this.name = name;
            }
            @Override
            public String toString() {
                return "呃呃呃-" + this.name;
            }
        }
        Weekday day = Weekday.SUN;
        if (day == Weekday.SUN) {
            // 返回定义的常量的顺序，从0开始计数
            System.out.println("今天是周末, 数值为：" + day.ordinal() + " ，中文名：" + day.name());  // 今天是周末, 数值为：0 ，中文名：SUN
        }
        if (day.dayValue == 0) {
            System.out.println("今天是周末, 数值为：" + day.dayValue + " ，中文名：" + day.toString() + " || " + day); // 今天是周末, 数值为：0 ，中文名：呃呃呃-星期天 || 呃呃呃-星期天
        }
        day = Weekday.MON;
        switch (day) {
            case MON:
            case TUE:
                System.out.println("Hmmmm, Today is a " + day);     // Hmmmm, Today is a 呃呃呃-星期一
                break;
            case WES:
            case SAT:
                System.out.println("Hmmmm, Today is a --- " + day);
                break;
            default:
                throw new RuntimeException("找不到对应的日期");
        }

    记录类  为了不让你用Lombok   没学完，后面再看
        // https://www.liaoxuefeng.com/wiki/1252599548343744/1331429187256353

    BigInteger
        // 和long型整数运算比，BigInteger不会有范围限制，但缺点是速度比较慢
        BigInteger bi = new BigInteger("100");
        System.out.println(bi.pow(5));      // 10000000000
        System.out.println(bi.longValue()); // 100
        // 如果BigInteger表示的范围超过了基本类型的范围，转换为基本类型时不一定是准确的。
        // 如果需要准确地转换成基本类型，可以使用intValueExact()、longValueExact()等方法，在转换时如果超出范围，将直接抛出ArithmeticException异常。
        System.out.println(bi.multiply(bi).longValueExact());   // 10000
        // 加法运算
        BigInteger bi2 = new BigInteger("12345678901234567890");
        System.out.println(bi2.add(bi));    // 12345678901234567990
        try {
            System.out.println(bi2.multiply(bi2).longValueExact());  // BigInteger out of long range
        } catch (ArithmeticException e) {
            System.out.println(e.getMessage());
        }

    BigDecimal   没学完，后面再看
        // https://www.liaoxuefeng.com/wiki/1252599548343744/1279768011997217
        BigDecimal bg = new BigDecimal("50.55");
        System.out.println(bg.multiply(bg));        // 2555.3025
        // 用scale()表示小数位数
        BigDecimal bg2 = new BigDecimal("50");
        BigDecimal bg3 = new BigDecimal("50.00");
        System.out.println(bg.multiply(bg).scale());        // 4
        System.out.println(bg.scale());         // 2
        System.out.println(bg2.scale());        // 0
        System.out.println(bg3.scale());        // 2

    Math 类
        System.out.println(Math.abs(-100));     // 100
        System.out.println(Math.max(100, 98));  // 100
        System.out.println(Math.min(100, 80));  // 80
        System.out.println(Math.pow(2, 3));     // 8.0
        System.out.println(Math.sqrt(9));       // 3.0
        System.out.println(Math.random());      // 0.7252868739713516
        // 伪随机数
        // 我们创建Random实例时，如果不给定种子，就使用系统当前时间戳作为种子，因此每次运行时，种子不同，得到的伪随机数序列就不同
        Random r = new Random();
        System.out.println(r.nextInt());        // 2071575453,每次都不一样
        System.out.println(r.nextInt(10));      // 5,生成一个[0,10)之间的int
        System.out.println(r.nextLong());       // 8811649292570369305,每次都不一样
        System.out.println(r.nextFloat());      // 0.54335...生成一个[0,1)之间的float
        System.out.println(r.nextDouble());     // 0.3716...生成一个[0,1)之间的double
        // 指定种子相同，伪随机数序列就相同
        r = new Random(30);
        System.out.println(r.nextInt(100));     // 6
        System.out.println(r.nextInt(100));     // 68
        Random rand = new Random();
        System.out.println(rand.nextInt(3));    // 输出 0 - 2 之间的整数
        // 真随机数
        SecureRandom sr = null;
        try {
            sr = SecureRandom.getInstanceStrong();  // 获取高强度安全随机数生成器
        } catch (NoSuchAlgorithmException e) {
            sr = new SecureRandom();    // 获取普通的安全随机数生成器
        }
        byte[] bArr = new byte[16];
        sr.nextBytes(bArr);     // 用安全随机数填充buffer
        System.out.println(Arrays.toString(bArr));  // [33, 58, -38, -76, -70, -52, 112, 7, 30, -14, -7, -69, 27, -29, -19, -23]
        System.out.println(sr.nextInt(100)); // 7

    命令行接受参数输入
        Scanner scannerObj = new Scanner(System.in);
        System.out.println("输入你的名字：");
        String name = scannerObj.nextLine();
        System.out.println("输入你的年龄：");
        int age2 = scannerObj.nextInt();
        System.out.printf("Hi, %s, you are %d years old", name, age2);


4、集合
    数组有如下限制: 数组初始化后大小不可变； 数组只能按索引顺序存取。
    集合: 可变大小的顺序链表 保证无重复元素的集合

    List
        定义：是一种有序列表，内部按照放入元素的先后顺序存放，每个元素都可以通过索引确定自己的位置。和数组几乎差不多。
        例子：
            // 使用 list , 优先使用 ArrayList
            //                  ArrayList	    LinkedList
            // 获取指定元素	    速度很快	        需要从头开始查找元素
            // 添加元素到末尾	    速度很快	        速度很快
            // 在指定位置添加/删除	需要移动元素	    不需要移动元素
            // 内存占用	        少	            较大

            // 创建 list
            // 方式 ①
            List<String> list = new ArrayList<>();
            list.add("apple");
            list.add("pear");
            list.add(null);
            list.add("banana");
            System.out.println(list.size());    // 4
            String second = list.get(1);
            System.out.println(second + ", " + list.get(2));    // pear, null
            // 方式 ②
            List<Integer> list2 = List.of(1, 4, 8);  // 不接受null值

            // 遍历 list
            List<String> list3 = List.of("aa", "bb", "cc");
            // ① 繁琐，不常用
            for (int i = 0; i < list3.size(); i++) {
                String s = list3.get(i);
                System.out.println(s);  // aa bb cc
            }
            // ② 写法复杂
            for (Iterator<String> it = list3.iterator(); it.hasNext();) {
                String s = it.next();
                System.out.println(s);  // aa bb cc
            }
            // ③ 自动把for each循环变成Iterator的调用
            for (String s: list3) {
                System.out.println(s);  // aa bb cc
            }

            // list 和 array 转换
            List<String> list4 = List.of("xx", "yy", "zz");
            // ① list -> array
            Object[] arr4 = list4.toArray();
            for (Object s: arr4) {
                System.out.println(s);  // xx yy zz
            }
            // ② list -> array
            String[] arr5 = list4.toArray(new String[3]);
            for (String s: arr5) {
                System.out.println(s);  // xx yy zz
            }
            // ③ list -> array      传入一个“恰好”大小的数组    常用
            // String[] arr6 = list4.toArray(new String[list4.size()]);
            String[] arr6 = list4.toArray(String[]::new);
            for (String s: arr6) {
                System.out.println(s);  // xx yy zz
            }

            // array -> list
            Integer[] arr7 = {1, 3, 5};
            List<Integer> list5 = List.of(arr7);
            // list5.add(99);       // 返回的是一个只读List,不能添加元素，否则报错：UnsupportedOperationException

            // list 常用函数
            List<String> list6 = List.of("A", "B", "C");
            System.out.println(list6.contains("C"));    // true
            System.out.println(list6.contains("c"));    // false
            System.out.println(list6.indexOf("C"));     // 2
            System.out.println(list6.indexOf("c"));     // -1

    Map
        定义：键值（key-value）映射表的数据结构，作用就是能高效通过key快速查找value（元素）
        注意：在Map的内部，对key做比较是通过equals()实现的，这一点和List查找元素需要正确覆写equals()是一样的
        例子：
            使用HashMap
                // HashMap是一种通过对key计算hashCode()，通过空间换时间的方式，直接定位到value所在的内部数组的索引，因此，查找效率非常高
                // map存整型
                Map<String, Integer> map = new HashMap<>();
                map.put("apple", 11);
                System.out.println(map.get("apple"));   // 11

                // map存对象
                Map<String, MyStudent> map2 = new HashMap<>();
                MyStudent msObj = new MyStudent("louis", 999);
                map2.put("louisXX", msObj);
                MyStudent msObj2 = map2.get("louisXX");
                System.out.println(msObj2);             // com.example.demo.testCollections.MyStudent@87aac27
                System.out.println(msObj2 == msObj);    // true, 同一个实例
                System.out.println(msObj2.score);       // 999
                MyStudent msObj3 = map2.get("louisYY");
                System.out.println(msObj3);             // null

                // 创建一个 HashMap
                HashMap<Integer, String> sites = new HashMap<>();
                // 往 HashMap 添加一些元素
                sites.put(1, "Google");
                sites.put(2, "Runoob");
                sites.put(3, "Taobao");
                System.out.println("sites HashMap: " + sites);

                // 创建另一个 HashMap
                HashMap<Integer, String> sites2 = new HashMap<>();
                sites2.put(1, "Weibo");  // 已存在会被替换
                sites2.put(4, "Wiki");
                // 将所有的映射关系从 sites 添加到 sites2
                sites2.putAll(sites);
                System.out.println("sites2 HashMap: " + sites2);

                // 遍历 map
                // 注意：键值对输出顺序随机
                // 方法①
                for (String key: map.keySet()) {
                    Integer value = map.get(key);
                    System.out.println(key + " - " + value);    // banana - 44   apple - 33   pear - 22
                }
                // 方法②
                for (Map.Entry<String, Integer> entry: map.entrySet()) {
                    String key = entry.getKey();
                    Integer value = entry.getValue();
                    System.out.println(key + " - " + value);    // banana - 44   apple - 33   pear - 22
                }

            使用EnumMap
                // EnumMap 在内部以一个非常紧凑的数组存储value，并且根据enum类型的key直接定位到内部数组的索引，并不需要计算hashCode()，效率最高，没有空间浪费
                Map<DayOfWeek, String> map4 = new EnumMap<>(DayOfWeek.class);
                map4.put(DayOfWeek.MONDAY, "星期一拉拉");
                map4.put(DayOfWeek.TUESDAY, "星期二拉拉");
                map4.put(DayOfWeek.WEDNESDAY, "星期三拉拉");
                System.out.println(map4);
                // {MONDAY=星期一拉拉, TUESDAY=星期二拉拉, WEDNESDAY=星期三拉拉}
                System.out.println(map4.get(DayOfWeek.MONDAY)); // 星期一拉拉

            使用TreeMap
                // SortedMap是接口，它的实现类是TreeMap，TreeMap在内部会对Key进行排序
                // TreeMap不使用equals()和hashCode()，所以无需覆写 equals()和hashCode()
                Map<String, Integer> map5 = new TreeMap<>();
                map5.put("orange", 11); map5.put("apple", 2); map5.put("pear", 3);
                for (String key:map5.keySet()) {
                    System.out.println(key);    // apple orange pear
                }
                // 使用TreeMap时，放入的Key必须实现Comparable接口。String、Integer这些类已经实现了Comparable接口，因此可以直接作为Key使用。作为Value的对象则没有任何要求。
                // 如果作为Key的class没有实现Comparable接口，那么，必须在创建TreeMap时同时指定一个自定义排序算法
                // TreeMap不需要覆盖 equals() 和 hashCode()
                public class HisStudent {
                    private String name;
                    public int age;

                    public HisStudent(String name, int age) {
                        this.name = name;
                        this.age = age;
                    }
                    @Override
                    public String toString() {
                        return "HisStudent{" + "name='" + name + '\'' + ", age=" + age + '}';
                    }
                }
                Map<HisStudent, Integer> map6 = new TreeMap<>(new Comparator<HisStudent>() {
                    public int compare(HisStudent hs1, HisStudent hs2) {
                        // 如果等于的情况注释，下面循环之后输出的那句话，就是 null
                        if (hs1.age == hs2.age) {
                            return 0;
                        }
                        return hs1.age > hs2.age ? -1 : 1;
                    }
                });
                map6.put(new HisStudent("Tom", 2), 2);
                map6.put(new HisStudent("Bob", 3), 3);
                map6.put(new HisStudent("louis", 1), 1);
                for (HisStudent key: map6.keySet()) {
                    System.out.println(key);
                    // HisStudent{name='Bob', age=3}
                    // HisStudent{name='Tom', age=2}
                    // HisStudent{name='louis', age=1}
                }
                System.out.println(map6.get(new HisStudent("louis", 1)));  // 1  ,  没有上面的 == 判断，这里就是 null

    Properties
        // 读取配置文件
        // 1、创建Properties实例
        // 2、调用load()读取文件
        // 3、调用getProperty()获取配置。
        // 方法 ①
        try {
            Properties props = new Properties();
            // load(InputStream)方法接收一个InputStream实例，表示一个字节流，它不一定读的文件流
            // 下面两个地址都行
            // String f = "src/main/java/com/example/demo/testCollections/test.properties";
            String f = "/Applications/XAMPP/xamppfiles/htdocs/my_practice22/my_java/yyyy/src/main/java/com/example/demo/testCollections/test.properties";
            // java.io.FileInputStream 以ASCII编码读取字节流
            // java.io.FileReader 支持中文，第二个参数指定编码
            props.load(new FileReader(f, StandardCharsets.UTF_8));
            String distributionUrl = props.getProperty("distributionUrl");
            String xxx = props.getProperty("xxx");
            System.out.println(distributionUrl + " " + xxx);    // ddddddd 111
        } catch (java.io.FileNotFoundException e) {
            System.out.println(e.getMessage());
        } catch (java.io.IOException e) {
            System.out.println(e.getMessage());
        }
        // ② 从jar包中读取的资源流：  没试验成功 ！！！
        ZzzzApplication zzzz = new ZzzzApplication();
        System.out.println(zzzz.getClass().getResourceAsStream("/Applications/XAMPP/xamppfiles/htdocs/my_practice22/my_java/yyyy/src/11.properties"));
        // ③ 从内存读取一个字节流
        try {
            String settings = "# test\n" + "course=Java\n" + "last_date=2019-08-07T12:35:01";
            ByteArrayInputStream input = new ByteArrayInputStream(settings.getBytes("UTF-8"));
            Properties props2 = new Properties();
            props2.load(input);
            System.out.println("course:" + props2.getProperty("course"));           // course:Java
            System.out.println("last_date:" + props2.getProperty("last_date"));     // last_date:2019-08-07T12:35:01
            System.out.println("last_file:" + props2.getProperty("last_file"));     // last_file:null
            System.out.println("auto_save:" + props2.getProperty("auto_save", "66")); // auto_save:66
        } catch (java.io.UnsupportedEncodingException e) {
            System.out.println(e.getMessage());
        } catch (java.io.IOException e) {
            System.out.println(e.getMessage());
        }

        // 写入配置文件
        try {
            Properties props3 = new Properties();
            props3.setProperty("url", "www.baidu.com");
            props3.setProperty("name", "百度");
            props3.store(new FileOutputStream("/Applications/XAMPP/xamppfiles/htdocs/my_practice22/my_java/yyyy/src/writeIn.properties"), "这是写入的注释");
        } catch (java.io.IOException e) {
            System.out.println(e.getMessage());
        }

    Set
        使用HashSet
            Set<String> set = new HashSet<>();
            // 将元素添加进Set<E>
            System.out.println(set.add("abc"));         // true
            System.out.println(set.add("xyz"));         // true
            System.out.println(set.add("yyy"));         // true
            // 判断是否包含元素
            System.out.println(set.contains("abc"));    // true
            System.out.println(set.contains("xxx"));    // false
            // 将元素从Set<E>删除
            System.out.println(set.remove("hello"));    // false
            System.out.println(set.remove("xyz"));      // true
            System.out.println(set.size());             // 2

        使用TreeSet
            // set 是接口，它的实现类是HashSet，HashSet是无序的，没有实现SortedSet接口
            // set 是接口，它的实现类是TreeSet，TreeSet是有序的，实现了SortedSet接口
            // TreeSet, 输出是有序的
            Set<String> set2 = new TreeSet<>();
            set2.add("apple"); set2.add("orange"); set2.add("pear"); set2.add("banana");
            for (String s: set2) {
                System.out.println(s);  // apple banana orange pear
            }

    Queue
        定义：Queue和List的区别在于，List可以在任意位置添加和删除元素，而Queue只有两个操作：把元素添加到队列末尾；从队列头部取出元素。
        注意：要避免把null添加到队列
                            throw Exception	    返回false或null
            添加元素到队尾	    add(E e)	        boolean offer(E e)
            取队首元素并删除	E remove()	        E poll()
            取队首元素但不删除	E element()	        E peek()
        例子：
            Queue<String> q = new LinkedList<>();
            // 添加
            try {
                q.add("apple");
                System.out.println("添加成功");     // 添加成功
            } catch (IllegalStateException e) {
                System.out.println(e.getMessage());
                System.out.println("添加失败");
            }
            if (q.offer("apple2")) {
                System.out.println("添加成功");     // 添加成功
            } else {
                System.out.println("添加失败");
            }
            // peek & poll 的区别
            Queue<String> q2 = new LinkedList<>();
            q2.offer("aaa");
            q2.offer("bbb");
            System.out.println(q2.peek());  // aaa
            System.out.println(q2.peek());  // aaa
            System.out.println(q2.poll());  // aaa
            System.out.println(q2.poll());  // bbb
            System.out.println(q2.poll());  // null  ,   因为队列是空的

    PriorityQueue
        定义：PriorityQueue和Queue的区别在于，它的出队顺序与元素的优先级有关，对PriorityQueue调用remove()或poll()方法，返回的总是优先级最高的元素
        例子：
            Queue<String> q5 = new PriorityQueue<>();
            q5.offer("mmm");
            q5.offer("xxx");
            q5.offer("nnn");
            System.out.println(q5.poll() + " " + q5.poll() + " " + q5.poll() + " " + q5.poll());    // mmm nnn xxx null
            // 实现Comparable接口，决定元素排序顺序，出队优先级
            public class User implements Comparable<User> {
                private String name;
                private String number;

                public User(String name, String number) {
                    this.name = name;
                    this.number = number;
                }
                public String toString() {
                    return this.name + "/" + this.number;
                }
                public int compareTo(User other) {
                    if (this.number.charAt(0) == other.number.charAt(0)) {
                        // return this.number.compareTo(other.number);   // 这么写有 bug
                        return Integer.parseInt(this.number.substring(1)) - Integer.parseInt(other.number.substring(1));
                    }
                    if (this.number.charAt(0) == 'V') {
                        // V 开头优先级高
                        return -1;
                    } else {
                        return 1;
                    }
                }
            }
            Queue<User> q6 = new PriorityQueue<>();
            q6.offer(new User("Bob", "A1"));
            q6.offer(new User("Alice", "A2"));
            q6.offer(new User("Alice", "A12"));
            q6.offer(new User("Boss", "V1"));
            System.out.println(q6.poll());  // Boss/V1
            System.out.println(q6.poll());  // Bob/A1
            System.out.println(q6.poll());  // Alice/A2
            System.out.println(q6.poll());  // Alice/A12
            System.out.println(q6.poll());  // null,因为队列为空

    deque
        定义：允许两头都进，两头都出，这种队列叫双端队列（Double Ended Queue），学名Deque
                             Queue	                Deque
            添加元素到队尾	    add(E e) / offer(E e)	addLast(E e) / offerLast(E e)
            取队首元素并删除	E remove() / E poll()	E removeFirst() / E pollFirst()
            取队首元素但不删除	E element() / E peek()	E getFirst() / E peekFirst()
            添加元素到队首	    无	                    addFirst(E e) / offerFirst(E e)
            取队尾元素并删除	无	                    E removeLast() / E pollLast()
            取队尾元素但不删除	无	                    E getLast() / E peekLast()
        例子：
            // Deque是一个接口，它的实现类有ArrayDeque和LinkedList
            Deque<String> deque = new LinkedList<>();
            deque.offerLast("A");   // A
            deque.offerLast("B");   // A <- B
            deque.offerFirst("C");  // C <- A <- B
            System.out.println(deque.pollFirst());  // C   ,  A <- B
            System.out.println(deque.pollLast());   // B   ,  A
            System.out.println(deque.pollFirst());  // A   ,  null
            // LinkedList真是一个全能选手，它即是List，又是Queue，还是Deque。但是我们在使用的时候，总是用特定的接口来引用它，
            //   这是因为持有接口说明代码的抽象层次更高，而且接口本身定义的方法代表了特定的用途。
            // 面向抽象编程的一个原则就是：尽量持有接口，而不是具体的实现类
            // 不推荐的写法
            LinkedList<String> d1 = new LinkedList<>();
            d1.offerLast("z");
            // 推荐的写法
            Deque<String> d2 = new LinkedList<>();
            d2.offerLast("z");
        小结：
            // LinkedList即实现了List接口，又实现了Queue接口，还实现了 Deque接口
            List<String> list8 = new LinkedList<>();
            Queue<String> q4 = new LinkedList<>();
            Deque<String> d2 = new LinkedList<>();

    Stack   例子有点复杂，先不看

    Iterator    例子有点复杂，先不看

    Collections     例子有点复杂，先不看


5、泛型
    概念：泛型的本质是为了参数化类型。在不创建新的类型的情况下，通过泛型指定的不同类型来控制形参具体限制的类型。可分为泛型类、泛型接口、泛型方法。
         一提到泛型，用到最多的就是在集合中，其实，在实际的编程过程中，可以使用泛型去简化开发，保证代码质量。
         泛型只在编译阶段有效，在编译之后程序会采取去泛型化的措施。
               在编译过程中，正确检验泛型结果后，会将泛型的相关信息擦出，并且在对象进入和离开方法的边界处添加类型检查和类型转换的方法。

    注意：泛型的继承关系，可以把ArrayList<Integer>向上转型为List<Integer>（T不能变！），
            但不能把ArrayList<Integer>向上转型为ArrayList<Number>（T不能变成父类）

    泛型标记符号：
        E - Element (在集合中使用，因为集合中存放的是元素)
        T - Type（Java 类）
        K - Key（键）
        V - Value（值）
        N - Number（数值类型）
        ？ - 表示不确定的 java 类型

    简单使用例子
        // 基本使用
        List<Number> list = new ArrayList<Number>();
        list.add(Integer.valueOf(33));
        list.add(Float.valueOf(13.44f));
        Number first = list.get(0);
        Number second = list.get(1);
        System.out.println(first + " " + second);   // 33 13.44
        // 可以省略后面的Number，编译器可以自动推断泛型类型：
        List<Number> list2 = new ArrayList<>();

    泛型类
        概念：泛型的类型参数只能是类类型（包括自定义类），不能是简单的基本类型
        例子：
            // 此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型
            // 在实例化泛型类时，必须指定T的具体类型
            public class Generic<T> {
                // key这个成员变量的类型为T,T的类型由外部指定
                private T key;

                // 泛型构造方法形参key的类型也为T，T的类型由外部指定
                public Generic(T key) {
                    this.key = key;
                }

                // 泛型方法getKey的返回值类型为T，T的类型由外部指定
                public T getKey() {
                    return key;
                }
            }
            Generic<Integer> generic11 = new Generic<Integer>(123456);
            Generic<String> generic22 = new Generic<String>("key_value");
            Generic<Boolean> generic33 = new Generic<Boolean>(false);
            System.out.println(generic11.getKey());     // 123456
            System.out.println(generic22.getKey());     // key_value
            System.out.println(generic33.getKey());     // false

            // 自定义的泛型类
            public class Pair<T> {
                private T first;
                private T second;

                public Pair(T first, T second) {
                    this.first = first;
                    this.second = second;
                }
                public T getFirst() {
                    return this.first;
                }
                public T getSecond() {
                    return this.second;
                }
                // 静态方法不能引用泛型类型<T>，必须定义其他类型（例如<K>）来实现静态泛型方法
                public static<X> Pair<X> create(X first, X second) {
                    return new Pair<X>(first, second);
                }
            }
            Pair<String> p2 = new Pair<>("hello", "world");
            String first2 = p2.getFirst();
            String second2 = p2.getSecond();
            System.out.println(first2 + ", " + second2);    // hello, world
            // 所有泛型实例，无论T的类型是什么，getClass()返回同一个Class实例，因为编译后它们全部都是Pair<Object>
            Pair<Integer> p3 = new Pair<>(99, 88);
            Class c1 = p2.getClass();
            Class c2 = p3.getClass();
            System.out.println((c1 == c2) + ", " + (c1 == Pair.class)); // true, true

    泛型接口
        // 定义一个泛型接口
        public interface Generator<T> {
            public T next();
        }
        // 实现泛型接口，未传入泛型实参       下面是泛型类
        public class FruitGenerator<T> implements Generator<T> {
            @Override
            public T next() {
                return null;
            }
        }
        Generator<Integer> gg = new FruitGenerator<Integer>();
        System.out.println(gg.next());      // null
        // 实现泛型接口，传入泛型实参    下面不是泛型类
        public class FruitGenerator22 implements Generator<String> {
            private String[] fruits = new String[]{"Apple", "banana", "pear"};

            @Override
            public String next() {
                Random rand = new Random();
                return fruits[rand.nextInt(3)];
            }
        }
        Generator<String> gg2 = new FruitGenerator22();
        System.out.println(gg2.next());     // banana

        // String本身已经实现了Comparable<String>接口,可以直接排序
        String[] ss = new String[] {"Orange", "Apple", "Pear"};
        Arrays.sort(ss);
        System.out.println(Arrays.toString(ss));        // [Apple, Orange, Pear]
        // String.compareTo 方法，逐个比较字符，并返回他们之间的ASCII长度差值
        System.out.println("zello".compareTo("bbb"));   // 24
        // 自定义一个类实现按name进行排序
        // 实现泛型接口
        public class PersonT implements Comparable<PersonT> {
            String name;
            int age;

            public PersonT(String name, int age) {
                this.name = name;
                this.age = age;
            }
            // 让PersonT实现Comparable<T>接口，从而自定义比较逻辑
            public int compareTo(PersonT other) {
                return this.name.compareTo(other.name);
            }
            public String toString() {
                return this.name + "," + this.age;
            }
        }
        PersonT[] ps = new PersonT[] {
                new PersonT("bob", 61),
                new PersonT("alice", 88),
                new PersonT("lily", 70)
        };
        Arrays.sort(ps);
        System.out.println(Arrays.toString(ps));        // [alice,88, bob,61, lily,70]

    泛型方法
        概念：泛型类定义时的 T 与泛型类方法中的泛型方法定义的 T 是不一样的，两者没毛线关系
        例子：
            // 例子一
            public class GenericMethod {

                /**
                 * 泛型方法的基本介绍
                 * @param tClass 传入的泛型实参
                 * @return T 返回值为T类型
                 * 说明：
                 *     1）public 与 返回值中间 <T> 非常重要，表明声明此方法为泛型方法。
                 *     2）只有声明了 <T> 的方法才是泛型方法，泛型类中使用了泛型的成员方法并不是泛型方法。
                 *     3）<T> 表明该方法将使用泛型类型T，此时才可以在方法中使用泛型类型T。
                 *     4）与泛型类的定义一样，此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型。
                 */
                public <T> T genericMethod(Class<T> tClass) throws InstantiationException, IllegalAccessException {
                    T instance = tClass.newInstance();
                    return instance;
                }
            }

            // 例子二
            public class GenericMethod22<T> {
                private T key;

                public GenericMethod22(T key) {
                    this.key = key;
                }

                // 我想说的其实是这个，虽然在方法中使用了泛型，但是这并不是一个泛型方法。
                // 这只是类中一个普通的成员方法，只不过他的返回值是在声明泛型类已经声明过的泛型。
                // 所以在这个方法中才可以继续使用 T 这个泛型。
                public T getKey(){
                    return key;
                }

                /**
                 * 这个方法显然是有问题的，在编译器会给我们提示这样的错误信息"cannot reslove symbol E"
                 * 因为在类的声明中并未声明泛型E，所以在使用E做形参和返回值类型时，编译器会无法识别。
                 */
            //    public E setKey(E key){
            //        this.key = key;
            //    }

                // 这也不是一个泛型方法，这就是一个普通的方法，只是使用了Generic<Number>这个泛型类做形参而已。
                public void showKeyValue1(Generic<Number> obj){
                    System.out.println("泛型测试 showKeyValue " + obj.getKey());
                }

                // 这也不是一个泛型方法，这也是一个普通的方法，只不过使用了泛型通配符?
                public void showKeyValue2(Generic<?> obj) {
                    System.out.println("泛型测试 showKeyValue2 " + obj.getKey());
                }

                /**
                 * 这个方法是有问题的，编译器会为我们提示错误信息："UnKnown class 'E' "
                 * 虽然我们声明了<T>,也表明了这是一个可以处理泛型的类型的泛型方法。
                 * 但是只声明了泛型类型T，并未声明泛型类型E，因此编译器并不知道该如何处理E这个类型。
                 */
            //    public <T> T showKeyName(Generic<E> container){
            //
            //    }

                /**
                 * 这个方法也是有问题的，编译器会为我们提示错误信息："UnKnown class 'T' "
                 * 对于编译器来说T这个类型并未项目中声明过，因此编译也不知道该如何编译这个类。
                 * 所以这也不是一个正确的泛型方法声明。
                 */
            //    public void showkey(T genericObj){
            //
            //    }
            }

            // 例子三
            public class GenericMethod33 {
                class Fruit {
                    @Override
                    public String toString() {
                        return "fruit";
                    }
                }

                class Apple extends Fruit {
                    @Override
                    public String toString() {
                        return "apple";
                    }
                }

                class Person {
                    @Override
                    public String toString() {
                        return "person";
                    }
                }

                class GenerateTest<T> {
                    public void show_1(T t) {
                        System.out.println(t.toString());
                    }

                    // 在泛型类中声明了一个泛型方法，使用泛型E，这种泛型E可以为任意类型。可以类型与T相同，也可以不同。
                    // 由于泛型方法在声明的时候会声明泛型<E>，因此即使在泛型类中并未声明泛型，编译器也能够正确识别泛型方法中的泛型。
                    public <E> void show_3(E t) {
                        System.out.println(t.toString());
                    }

                    // 在泛型类中声明了一个泛型方法，使用泛型T，注意这个T是一种全新的类型，可以与泛型类中声明的T不是同一种类型。
                    public <T> void show_2(T t) {
                        System.out.println(t.toString());
                    }
                }

                public void xxxx() {
                    Apple apple = new Apple();
                    Person person = new Person();

                    GenerateTest<Fruit> generateTest = new GenerateTest<Fruit>();
                    // apple是Fruit的子类，所以这里可以
                    generateTest.show_1(apple);     // apple
                    // 编译器会报错，因为泛型类型实参指定的是Fruit，而传入的实参类是Person
            //        generateTest.show_1(person);
                    // 使用这两个方法都可以成功
                    generateTest.show_2(apple);     // apple
                    generateTest.show_2(person);    // person
                    // 使用这两个方法都可以成功
                    generateTest.show_3(apple);     // apple
                    generateTest.show_3(person);    // person
                }
            }
            GenericMethod33 gg5 = new GenericMethod33();
            gg5.xxxx();

            // 泛型方法与可变参数
            ZzzzApplication zzzzObj = new ZzzzApplication();
            public <T> void printMsg(T... args) {
                for (T t:args) {
                    System.out.println("t is " + t);
                }
            }
            zzzzObj.printMsg("111", "222", "aaaa", "232.44");
            // t is 111
            // t is 222
            // t is aaaa
            // t is 232.44

    泛型通配符
        概念：解决具有父子关系的泛型类型，比如 Generic<Number> 和 Generic<Integer>
        例子：
            Generic<Integer> gg3 = new Generic<>(123);
            Generic<Number> gg4 = new Generic<>(456);
            // 此处 '?' 是类型实参，而不是类型形参。用来代替具体的类型实参，
            // 直白点就是，此处的 ? 和Number、String、Integer一样都是一种实际的类型，可以把 ? 看成所有类型的父类
            public void showKeyValue(Generic<?> obj) {
                System.out.println("泛型通配符测试：" + obj.getKey());
            }
            zzzzObj.showKeyValue(gg3);      // 泛型通配符测试：123
            zzzzObj.showKeyValue(gg4);      // 泛型通配符测试：456

    泛型上下边界
        概念：为泛型添加上边界，即传入的类型实参必须是指定类型的子类型
        例子：
            public static void getMyNumber(List<? extends Number> data) {
                System.out.println("泛型上下边界测试：" + data.get(0));
            }
            List<String> name = new ArrayList<String>();
            List<Integer> age = new ArrayList<Integer>();
            List<Number> number = new ArrayList<Number>();
            name.add("icon");
            age.add(18);
            number.add(314);
            // getMyNumber(name);   // 不兼容的类型: java.util.List<java.lang.String>无法转换为java.util.List<? extends java.lang.Number>
            getMyNumber(age);       // 泛型上下边界测试：18
            getMyNumber(number);    // 泛型上下边界测试：314

            public class Generic22<T extends Number> {
                private T key;

                public Generic22(T key) {
                    this.key = key;
                }

                public T getKey() {
                    return key;
                }
            }
            // 这行代码会报错，因为String不是Number的子类
            // Generic22<String> gg55 = new Generic22<String>("1111");
            Generic22<Integer> gg66 = new Generic22<Integer>(2222);
            Generic22<Float> gg77 = new Generic22<Float>(2.4f);
            Generic22<Double> gg88 = new Generic22<Double>(2.56);

            public void showKeyValue22(Generic22<? extends Number> obj) {
                System.out.println("showKeyValue22 " + obj.getKey());
            }
            // zzzzObj.showKeyValue22(gg55);
            zzzzObj.showKeyValue22(gg66);   // showKeyValue22 2222
            zzzzObj.showKeyValue22(gg77);   // showKeyValue22 2.4
            zzzzObj.showKeyValue22(gg88);   // showKeyValue22 2.56

            // 另一个泛型方法设置界限的例子
            // 在泛型方法中添加上下边界限制的时候，必须在权限声明与返回值之间的<T>上添加上下边界，即在泛型声明的时候添加
            // public <T> T showKeyName(Generic<T extends Number> container)，编译器会报错："Unexpected bound"
            public <T extends Number> T showKeyName(Generic<T> container) {
                System.out.println("container key: " + container.getKey());
                T test = container.getKey();
                return test;
            }

    泛型擦除
        // 泛型类型擦除，暂时不研究，原理层面跟反射有关系

    参考博文：https://blog.csdn.net/m0_49508485/article/details/123070574  文章写得不错，可以再看看他写的其它文章


6、注解（Annotation）
    定义：是Java语言用于工具处理的标注
    例子：
         可以修饰其他注解，这些注解就称为元注解（meta annotation）
             @Target可以定义Annotation能够被应用于源码的哪些位置
                 类或接口：ElementType.TYPE；
                 字段：ElementType.FIELD；
                 方法：ElementType.METHOD；
                 构造方法：ElementType.CONSTRUCTOR；
                 方法参数：ElementType.PARAMETER
             @Retention定义了Annotation的生命周期
                 仅编译期：RetentionPolicy.SOURCE；
                     注解在编译期就被丢掉了
                     主要由编译器使用，因此我们一般只使用，不编写
                 仅class文件：RetentionPolicy.CLASS；
                     注解仅保存在class文件中，它们不会被加载进JVM
                     主要由底层工具库使用，涉及到class的加载，一般我们很少用到
                 运行期：RetentionPolicy.RUNTIME
                     注解会被加载进JVM，并且在运行期可以被程序读取
                     不但要使用，还经常需要编写
             @Repeatable可以定义Annotation是否可重复。应用不是特别广泛。
             @Inherited定义子类是否可继承父类定义的Annotation
             @override 让编译器检查该方法是否正确地实现了覆写


7、Lambda
    定义：Lambda 表达式，也可称为闭包，简化了Java的函数式编程
    例子：
        public class ZzzzApplication {
            final static String salutation = "that's the truth";
            interface MathOperation {
                int operation(int a, int b);
            }
            private int operate(int a, int b, MathOperation mathOperation) {
                return mathOperation.operation(a, b);
            }
            interface GreetingService {
                void sayMessage(String message);
            }
            public interface Converter<T1, T2> {
                void convert(int i);
            }
        }
        // lambda 表达式写法
        ZzzzApplication tester = new ZzzzApplication();
        // ① 类型声明
        MathOperation addition = (int a, int b) -> a + b;
        // ② 无类型声明
        MathOperation subtraction = (a, b) -> a - b;
        // ③ 用括号返回语句
        MathOperation multiplication = (int a, int b) -> {return a * b;};
        System.out.println("a+b= " + tester.operate(10, 5, addition));  // a+b= 15
        System.out.println("a-b= " + tester.operate(10, 5, subtraction));   // a-b= 5
        System.out.println("a*b= " + tester.operate(10, 5, multiplication));    // a*b= 50
        // ④ 不用括号
        GreetingService gs1 = message -> System.out.println("hello " + message);
        gs1.sayMessage("baidu");    // hello baidu

        // lambda 变量作用域
        // 引用标记了 final 的外层局部变量
        GreetingService gs2 = message -> System.out.println("people " + salutation + message);
        gs2.sayMessage(" louis");  // people that's the truth louis
        // lambda 表达式的局部变量可以不用声明为 final，但是必须不可被后面的代码修改（即隐性的具有 final 的语义）
        // 在 Lambda 表达式当中不允许声明一个与局部变量同名的参数或者局部变量，否则报错
        final int num = 1;
        int num22 = 2;
        Converter<Integer, String> conRes = (param) -> System.out.println(String.valueOf(param + num + num22));
        conRes.convert(2);  // 5


X、其它
    Java编程基本规则：出现问题，不要怀疑Java标准库，要从自身代码找原因。






