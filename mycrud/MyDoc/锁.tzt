锁膨胀过程 ？ 自旋，公平，非公共，AQS

乐观锁：
    数据库中乐观锁的实现一般采用版本号，Java中可使用CAS实现乐观锁。
    CAS（自旋锁）：CAS是从乐观的角度出发，尝试用新值更新内存值，更新时会判断内存值是否被别人修改过，如果没有则直接更新。如果被修改过，
        则重新获取最新值再继续尝试更新，直到更新成功为止，所以CAS方式也称自旋锁。

    CAS（Compare And Set 或 Compare And Swap）
       定义：
            CAS 即比较并修改的意思。CAS技术可以保证操作的原子性，atomic包下的原子类都是基于CAS和volatile实现原子操作的。
       原理：
            例如：AtomicInteger类下的getAndIncrement() 方法
                1. 调用getIntVolatile方法，根据对象地址获取预期值v。
                2. 调用CAS方法，如果 预期值v 和 内存值 相同，则更新内存值为 v+delta，更新成功返回true，循环结束。
                3. 如果预期值 v 和内存最新值不相同（也就是此期间有其他线程更新了内存值），则更新失败，循环继续重新取出预期值。
                自旋：不断的循环，尝试更新内存
       特点：
            当线程较少时，实现自旋效率最好，因为修改次数少，判断次数少，当线程竞争强烈（多）时，应该采用加锁的方法。

    实现方式：
        1.版本号
        2.CAS
        3.原子类（Java的java.util.concurrent.atomic包下）

悲观锁：
    synchronized总是从最坏的角度出发，认为每次获取数据的时候，别人都有可能修改。所以在每次操作共享数据之前，都会上锁。（悲观锁）

    实现方式:
        synchronized 和 Lock

CAS 和 syncronized 的比较
    CAS线程不会阻塞，线程一致自旋
    syncronized会阻塞线程，会进行线程的上下文切换，会由用户态切换到内核态，切换前需要保存用户态的上下文，而内核态恢复到用户态，又需要恢复保存的上下文，非常消耗资源。


公平锁
    定义：指多个线程按照申请锁的顺序来获取锁；

非公平锁
    定义：指多个线程获取锁的顺序是随机的，并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁。
    有可能，会造成优先级反转或者饥饿现象。
    饥饿现象
        线程一直无法获取锁或其他资源，导致线程一直无法到执行的状态；
        导致无法获取的原因:
            线程优先级较低,没办法获取cpu时间；
            其他线程总是能在它之前持续地对该同步块进行访问；
            线程在等待一个本身也处于永久等待完成的对象(比如调用这个对象的 wait 方法)，因为其他线程总是被持续地获得唤醒；

公平锁 & 非公平锁的实现方式:
    ReenTrantLock(公平(true)/非公平(false))

    对于Java ReentrantLock而言，通过构造函数指定该锁是否是公平锁，默认是非公平锁。非公平锁的优点在于吞吐量比公平锁大；
    对于Synchronized而言，也是一种非公平锁。由于其并不像ReentrantLock是通过AQS的控制线程对锁的获取， 所以并没有任何办法使其变成公平锁；

对象头(MarkDown)
    在JVM的实现中每一个对象都会有一个对象头，它是用于保存对象的系统信息，对象头中有一个官方称为 MarkDown 的部分，他就是实现各种锁的关键；
    存放了对象的哈希值、对象年龄、锁的指针等等信息，总之就是一个对象的锁是否被占用、占用的是哪种锁，就记录在MarkDown中；

偏向锁
    定义：当前只有这个线程获得，没有发生争抢，此时将方法头的markword设置成0，然后每次过来都cas一下就好，不用重复的获取锁，降低获取锁的代价；
        无锁（标志位为01）
        轻量级锁（标志位为00）

轻量级锁
    定义：在偏向锁的基础上，有线程来争抢，此时膨胀为轻量级锁，多个线程获取锁时用cas自旋获取，而不是阻塞状态

重量级锁
    定义：轻量级锁自旋一定次数后，膨胀为重量级锁，其他线程阻塞，当获取锁线程释放锁后唤醒其他线程。
        当有一个线程获取重量级锁之后，其余所有等待获取该锁的线程都会处于阻塞状态，操作系统实现线程之间的切换需要从用户态切换到内核态，而转换状态是需要消耗很多时间的，有可能比用户执行代码的时间还要长，所以它的切换成本非常高，这同时也说明了为什么重量级线程开销很大的原因；
        重量级锁也被成为互斥锁；
    实现方式: synchronized

自旋锁
    自旋锁是指尝试获取锁的线程不会阻塞，而是采用循环的方式尝试获取锁。
    好处是减少上下文切换，缺点是一直占用CPU资源；

AQS
    核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并将共享资源设置为锁定状态，如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制AQS是用CLH队列锁实现的，即将暂时获取不到锁的线程加入到队列中。
    大白话：AQS就是基于CLH队列，用volatile修饰共享变量state，线程通过CAS去改变状态符，成功则获取锁成功，失败则进入等待队列，等待被唤醒。

    CLH（Craig，Landin，and Hagersten）队列是一个虚拟的双向队列，虚拟的双向队列即不存在队列实例，仅存在节点之间的关联关系。
    AQS是将每一条请求共享资源的线程封装成一个CLH锁队列的一个结点（Node），来实现锁的分配。

    共享资源：共享资源是一个volatile的int类型变量。
    等待队列：等待队列是一个线程安全的队列，当线程拿不到锁时，会被park并放入队列。
    新线程：非公平情况下，新线程会先尝试直接获取资源，获取不到才进入队列。

    实现了AQS的锁有：自旋锁、互斥锁、读锁写锁、条件产量、信号量、栅栏都是AQS的衍生物。这些类内部持有一个AbstractQuenedSynchronizer的实例，通过该实例，实现共享、独占等特性。

互斥锁：同一时间，只有一个线程能访问某个资源
    ReentrantLock和Synchronized、都是互斥锁

共享锁：允许2个以上的线程同时访问 。信号量、栅栏，都是共享锁

读写锁：与互斥锁不同的是读写锁的规则是可以共享读，但只能一个写。涵盖了互斥锁和共享锁

参考资料：
    https://blog.csdn.net/m0_45406092/article/details/118303467
    https://zhuanlan.zhihu.com/p/407046495

